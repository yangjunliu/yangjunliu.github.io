<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>独立开发者 0 成本上线指南（学生党 &amp; 初创团队福音）</title>
      <link href="/rainbow-bubbles/VibeCoding/vibe-coding-No3/"/>
      <url>/rainbow-bubbles/VibeCoding/vibe-coding-No3/</url>
      
        <content type="html"><![CDATA[<h1 id="独立开发者-0-成本上线指南（学生党-初创团队福音）"><a href="#独立开发者-0-成本上线指南（学生党-初创团队福音）" class="headerlink" title="独立开发者 0 成本上线指南（学生党 &amp; 初创团队福音）"></a>独立开发者 0 成本上线指南（学生党 &amp; 初创团队福音）</h1><p>很多独立开发者、学生党或者初创公司，刚起步时没资金投入昂贵的服务器、数据库、监控工具。这时候，<strong>善用免费工具和云平台的免费额度，就能 0 成本上线产品，快速验证想法。</strong></p><p>今天我整理了一套【免费开发部署工具清单】，涵盖从代码托管到部署、数据库、CDN、缓存、日志、任务调度等一整套生产链路，适合做<strong>全栈项目 MVP 验证 &#x2F; SaaS Demo &#x2F; AI 应用初版</strong>。</p><h2 id="一、域名解析"><a href="#一、域名解析" class="headerlink" title="一、域名解析"></a>一、域名解析</h2><ul><li><strong>Cloudflare</strong><br>免费 DNS 服务 + CDN + 访问防护</li></ul><h2 id="二、代码仓库"><a href="#二、代码仓库" class="headerlink" title="二、代码仓库"></a>二、代码仓库</h2><ul><li><strong>GitHub</strong><br>免费私有仓库 + 自动化部署支持</li></ul><h2 id="三、容器部署"><a href="#三、容器部署" class="headerlink" title="三、容器部署"></a>三、容器部署</h2><ul><li><strong>Zeabur</strong>：中文支持友好，部署便捷  </li><li><strong>Fly.io</strong>：支持 Docker，全球节点部署  </li><li><strong>Claw Cloud</strong>：轻量级容器平台，开发者友好</li></ul><h2 id="四、静态网站部署"><a href="#四、静态网站部署" class="headerlink" title="四、静态网站部署"></a>四、静态网站部署</h2><ul><li><strong>Vercel</strong>：支持 React&#x2F;Next.js，自动部署  </li><li><strong>Netlify</strong>：支持表单、函数、自动构建  </li><li><strong>Cloudflare Pages</strong>：轻量部署，免费额度充足</li></ul><h2 id="五、数据库"><a href="#五、数据库" class="headerlink" title="五、数据库"></a>五、数据库</h2><ul><li><strong>Supabase</strong>：PostgreSQL + 鉴权 + 存储  </li><li><strong>PlanetScale</strong>：MySQL 架构下弹性扩展  </li><li><strong>Cloudflare D1</strong>：基于 SQLite，适合边缘部署  </li><li><strong>Neon</strong>：支持 serverless 的 Postgres 数据库</li></ul><h2 id="六、数据缓存"><a href="#六、数据缓存" class="headerlink" title="六、数据缓存"></a>六、数据缓存</h2><ul><li><strong>Upstash Redis</strong>：serverless Redis，集成方便</li></ul><h2 id="七、对象存储"><a href="#七、对象存储" class="headerlink" title="七、对象存储"></a>七、对象存储</h2><ul><li><strong>Cloudflare R2</strong>：无出站流量费  </li><li><strong>Backblaze B2</strong>：经济型 S3 替代方案</li></ul><h2 id="八、消息中间件"><a href="#八、消息中间件" class="headerlink" title="八、消息中间件"></a>八、消息中间件</h2><ul><li><strong>Upstash Kafka&#x2F;Queue</strong>：轻量异步任务队列</li></ul><h2 id="九、定时任务"><a href="#九、定时任务" class="headerlink" title="九、定时任务"></a>九、定时任务</h2><ul><li><strong>Cloudflare Worker Cron Trigger</strong>  </li><li><strong>cron-job.org</strong>：适合基础定时任务调度</li></ul><h2 id="十、日志监控"><a href="#十、日志监控" class="headerlink" title="十、日志监控"></a>十、日志监控</h2><ul><li><strong>Axiom</strong>：日志聚合、查询、可视化分析</li></ul><h2 id="十一、CDN-加速"><a href="#十一、CDN-加速" class="headerlink" title="十一、CDN 加速"></a>十一、CDN 加速</h2><ul><li><strong>Cloudflare CDN</strong>：支持静态内容、边缘缓存</li></ul><h2 id="十二、邮件服务"><a href="#十二、邮件服务" class="headerlink" title="十二、邮件服务"></a>十二、邮件服务</h2><ul><li><strong>Mailgun</strong>：适合系统邮件、注册验证码等</li></ul><hr><p>这些工具组合起来，足以让你 0 成本开发上线一个完整项目，从前端、后端、数据库、调度任务到日志和 CDN 一应俱全。非常适合：</p><ul><li>学生党交作业 &#x2F; 练手  </li><li>独立开发者发布 MVP  </li><li>初创团队验证产品可行性</li></ul><p>💡 等项目开始有用户、有营收后，再考虑扩容、升级服务。</p>]]></content>
      
      
      <categories>
          
          <category> AIGC </category>
          
          <category> 常用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
            <tag> free tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VSCode编码助手，RooCode使用</title>
      <link href="/rainbow-bubbles/VibeCoding/vibe-coding-No2/"/>
      <url>/rainbow-bubbles/VibeCoding/vibe-coding-No2/</url>
      
        <content type="html"><![CDATA[<h1 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h1><p>由于AI的快速发展使得各行各业都在寻找AI能够切实落地的方案，目前也可以说遍地开花也不为过。自媒体行业图文生成大大帮助了自媒体创作者的创作效率；教育行业具体问题的分析和讲解能力不逊色于一般水平的老师；医疗行业现在普遍是看报告的判断病情的时代AI觉得比人的判断效率更高更准；程序员这个行业哪些重复的增删查改工作交给AI来做真是太好了。这边文章就是从程序员的角度去了解和实践AI对这个行业帮助，把哪些重复的复制黏贴工作交给AI来做。</p><h1 id="二、VSCode-和-RooCode的使用"><a href="#二、VSCode-和-RooCode的使用" class="headerlink" title="二、VSCode 和 RooCode的使用"></a>二、VSCode 和 RooCode的使用</h1><p>程序员这个行业应该没有人不知道VSCode。RooCode是这次介绍的主角，VSCode的一个插件用来调用大模型和管理大模型接口。</p><h2 id="1-安装VSCode"><a href="#1-安装VSCode" class="headerlink" title="1. 安装VSCode"></a>1. 安装VSCode</h2><p>安装软件比较简单，下载然间然后双击打开一直下一步。如果想修改安装环境记得在安装过程中修改一下。<br>点击链接下载： <a href="https://code.visualstudio.com/Download">https://code.visualstudio.com/Download</a><br>选择对应自己的操作系统<br><img src="https://r2.721503.xyz/blog/1748689529671.png"></p><h2 id="2-下载Roo-Code插件"><a href="#2-下载Roo-Code插件" class="headerlink" title="2. 下载Roo Code插件"></a>2. 下载Roo Code插件</h2><p>安装完成后双击打开，打开界面左侧的扩展按钮，在搜索框中搜索<strong>Roo Code</strong>，找到对应扩展，点击<strong>Install</strong>按钮进行安装：<br><img src="https://r2.721503.xyz/blog/1748690098318.png"><br><img src="https://r2.721503.xyz/blog/1748690155361.png"><br>安装过程中可能需要输入确定，输入确定下一步就好了。</p><h2 id="3-配置Roo-Code"><a href="#3-配置Roo-Code" class="headerlink" title="3. 配置Roo Code"></a>3. 配置Roo Code</h2><ol><li><p>点击左侧小袋鼠的图标打开插件，点击设置的图标我们可以看到有很多需要配置的参数，左侧框住的部分是所有的设置选项，后面会讲。<br><img src="https://r2.721503.xyz/blog/1748690934656.png"></p></li><li><p>配置google Gemini大模型<br>看上图需要Gemini 大模型的API密钥，去们先去获取密钥然后填进去。</p></li></ol><ul><li>获取API密钥：<br><a href="https://aistudio.google.com/apikey">https://aistudio.google.com/apikey</a> 根据提示完成注册<br>点击创建密钥<br><img src="https://r2.721503.xyz/blog/1748691526207.png"><br>创建完成点击复制密钥<br><img src="https://r2.721503.xyz/blog/1748691567925.png"></li><li>使用roo code<br>把密钥复制进来，选择对应的模型版本。版本中包含exp的为免费版本。其他的可以先保持默认。<br><img src="https://r2.721503.xyz/blog/1748691778635.png"></li></ul><h2 id="4-试一下"><a href="#4-试一下" class="headerlink" title="4. 试一下"></a>4. 试一下</h2><p>让他先写一个小游戏试试</p><ul><li>在文件管理中打开或创建一个文件夹</li><li>然后再点击小袋鼠的图标，再提示框中输入这段文字。然后回车发送消息。<br><img src="https://r2.721503.xyz/blog/1748692469030.png"></li><li>开始执行，更具提示词写代码<br><img src="https://r2.721503.xyz/blog/1748693108542.png"></li><li>任务完成，运行代码<br><img src="https://r2.721503.xyz/blog/1748693236670.png"><br>小实验完成，看着还是挺不错的。</li></ul><h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p>这知识一个小的demo，后面还可以更精细化的配置，让他一步一步按照我们写的TODO List生成代码，可玩性还是很高的。</p>]]></content>
      
      
      <categories>
          
          <category> AIGC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> vibe coding </tag>
            
            <tag> RooCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>介绍vibe coding</title>
      <link href="/rainbow-bubbles/VibeCoding/vibe-coding-No1/"/>
      <url>/rainbow-bubbles/VibeCoding/vibe-coding-No1/</url>
      
        <content type="html"><![CDATA[<h1 id="利用AI完成一个小型互联网工作室的实践探索"><a href="#利用AI完成一个小型互联网工作室的实践探索" class="headerlink" title="利用AI完成一个小型互联网工作室的实践探索"></a>利用AI完成一个小型互联网工作室的实践探索</h1><h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>这只是我一个想法，抱着“试试看”的心态去实践的。各行各业的大佬或天马行空的创意者都欢迎一起来探讨这个方向。</p><p>近几年，AI-generated content（AI生成内容）发展非常迅速，最常见的应用包括图像生成、程序员圈中的自动生成代码等。网上也有很多相关教程介绍这些内容。从这个趋势来看，未来AI势必会对我们的生活和工作产生深远影响。</p><p>所以我突然冒出了一个想法：**尝试使用AI完成一个小型互联网工作室的全部工作内容。**因为我本身是程序员出身，就从自己相对熟悉的代码生成方向入手，进而尝试让AI完成整个互联网项目开发流程中每个角色的任务，包括：</p><blockquote><p>发掘需求 → 分析需求 → 确定产品 → UI设计 → 技术选型与架构设计 → 前后端开发 → 产品测试 → 运营推广</p></blockquote><p>下面是我详细的实操过程分享。</p><hr><h2 id="二、详细介绍各个部分（含实操例子）"><a href="#二、详细介绍各个部分（含实操例子）" class="headerlink" title="二、详细介绍各个部分（含实操例子）"></a>二、详细介绍各个部分（含实操例子）</h2><h3 id="1-发掘需求"><a href="#1-发掘需求" class="headerlink" title="1. 发掘需求"></a>1. 发掘需求</h3><p>这个部分是整个项目的开始，也是最难、最关键的一环。一般这个阶段是由老板亲自负责，决定了产品的方向与定位。应该多花时间在早期的市场调研、成本预估、周期规划和后期变现方式上。</p><p>很多产品难产的原因，往往就是调研不充分。当然，失败的原因还有很多。</p><p>🔹<strong>AI实操例子</strong>：<br>我向大模型提问当前有哪些低成本、易入门的创业方向。AI返回了“单身经济”“语言学习”“小众旅游”等方向。我进一步追问哪个方向投入少、收益稳定，AI建议“英语口语练习”较为适合小团队，于是我选择了“AI语音口语陪练”作为实验项目。</p><hr><h3 id="2-分析需求"><a href="#2-分析需求" class="headerlink" title="2. 分析需求"></a>2. 分析需求</h3><p>方向确定后，老板会找产品经理沟通产品定位。很多时候产品经理从发掘阶段就开始介入了。这个环节大致包括：</p><ul><li>查找市场上已有的相关产品，筛选几个排名高的和排名低的对比；</li><li>实地体验这些产品，记录它们的优缺点；</li><li>汇总信息，构建自己产品的雏形；</li><li>产品、需求、技术多部门沟通，结合预算与周期确定最终的功能范围。</li></ul><p>👂<strong>题外话</strong>：<br>程序员常听PM说：“别家APP这个功能都能做，你为啥不行？”哈哈哈。程序员也会吐槽产品经理：“这工作也太好干了吧，拼拼凑凑做个四不像。” 这类段子非常多~</p><p>🔹<strong>AI实操例子</strong>：<br>我用AI分析英语学习类APP，找到了“英语流利说”“Tandem”等几个典型产品，然后让AI总结每个产品的特色与短板，最后基于这些总结让AI生成我的MVP功能清单。</p><hr><h3 id="3-UI设计"><a href="#3-UI设计" class="headerlink" title="3. UI设计"></a>3. UI设计</h3><p>UI部门在拿到线框图后开始做视觉设计，并与产品部门反复沟通确认，直到确定最终版。最终输出的设计图需包含尺寸标准和切图资源，交给前端使用。</p><p>🔹<strong>AI实操例子</strong>：<br>我使用了AI绘图工具（如Midjourney）生成界面原型。提示词如下：  </p><blockquote><p>“设计一款年轻化、蓝白主色调的英语学习APP首页，采用卡片式布局。”</p></blockquote><p>结果AI生成的效果图基本可以直接拿去前端实现。</p><hr><h3 id="4-技术选型与架构设计"><a href="#4-技术选型与架构设计" class="headerlink" title="4. 技术选型与架构设计"></a>4. 技术选型与架构设计</h3><p>技术部门拿到需求后，会根据预计用户量与产品生命周期选择技术方案。大多数初创项目都选用开源成熟的技术栈。因为我是程序员出身，熟悉Node.js，同时很多Node的部署资源都可以免费白嫖，主打一个“零成本起步”。</p><p>🔹<strong>AI实操例子</strong>：<br>我输入产品背景，要求AI推荐合适的技术栈与服务架构。AI推荐了：</p><ul><li>Node.js + Express 后端</li><li>MongoDB 数据库</li><li>Redis 缓存</li><li>免费服务器部署（如Vercel、Render）</li></ul><p>甚至还画出了项目架构图、目录结构和数据库模型。</p><hr><h3 id="5-前端技术选型与开发"><a href="#5-前端技术选型与开发" class="headerlink" title="5. 前端技术选型与开发"></a>5. 前端技术选型与开发</h3><p>前端方向包括iOS、Android、桌面、Web等。小程序本质也是Web。由于我主要是Web方向的经验，这次就以Web为主，后期也可以打包为小程序。</p><p>🔹<strong>AI实操例子</strong>：<br>我用RooCode初始化前端项目，提示词大致为：  </p><blockquote><p>“使用Vue3 + Vite，支持路由和状态管理，首页展示语音练习卡片和评分结果。”</p></blockquote><p>AI生成了项目模板，接入了语音识别API，还包含了基础样式和测试代码。</p><hr><h3 id="6-后端技术选型与开发"><a href="#6-后端技术选型与开发" class="headerlink" title="6. 后端技术选型与开发"></a>6. 后端技术选型与开发</h3><p>后端一般承担数据接口、数据库操作、缓存、鉴权、日志等任务。我的后端经验比前端更丰富，感觉后端更适合AI操控，因为大语言模型在处理文字结构上的能力更强。</p><p>🔹<strong>AI实操例子</strong>：<br>我输入了以下请求：  </p><blockquote><p>“请为语音打分应用设计数据表，生成MongoDB模型、API接口文档，并生成路由、控制器和单元测试代码。”</p></blockquote><p>AI成功输出了所有内容，我按需微调即可完成后端项目。</p><hr><h3 id="7-产品体验与测试"><a href="#7-产品体验与测试" class="headerlink" title="7. 产品体验与测试"></a>7. 产品体验与测试</h3><p>QA（质量保证）是产品开发的最后阶段。需要判断开发成果是否符合预期，以及产品的质量是否达标。产品质量会直接影响用户体验，甚至决定产品的生死。</p><p>🔹<strong>AI实操例子</strong>：<br>我用Playwright生成自动化测试脚本，验证注册流程、打分流程是否正常。同时让AI评估用户操作流程是否存在流失风险，AI建议添加“跳过注册”选项和快速体验入口。</p><hr><h3 id="8-运营推广"><a href="#8-运营推广" class="headerlink" title="8. 运营推广"></a>8. 运营推广</h3><p>运营主要分析用户数据（日活、留存、转化），并做广告投放、流量变现等工作。</p><p>🔹<strong>AI实操例子</strong>：<br>我让AI分析模拟的用户数据（第1天留存20%，第7天留存不到5%），AI给出运营建议：</p><ul><li>添加打卡机制和积分系统</li><li>第3天推送“回归奖励”</li><li>针对不同用户分层定向推送通知</li></ul><p>我还用AI写了公众号文案、SEO标题和APP商店的描述内容。</p><hr><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>最近程序员圈关于代码生成的AI工具如雨后春笋般出现，更新速度惊人。只要我们善用这些工具，就能大幅提升开发效率、节省人力成本。</p><p>虽然现在的AI仍不完美，但雏形与发展方向已基本清晰。它将成为程序员和创作者们的重要助手，甚至替代一部分初级岗位。</p><p>真正的难点是：<strong>如何设计高质量提示词，让AI准确理解你的需求。</strong> 只要我们持续实践、不断优化提示词，引导AI为我们服务，它的潜力是巨大的。</p><p>其他行业我不太了解，但我相信AI在程序员领域一定会有非常好的发展。<br>欢迎一起学习交流，共勉！</p><hr><p>如果你觉得这篇文章对你有帮助，欢迎点赞、收藏、转发，也欢迎评论区分享你在AI实践中的经验！</p>]]></content>
      
      
      <categories>
          
          <category> AIGC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> vibe coding </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>roots第二篇</title>
      <link href="/rainbow-bubbles/IELTS/rootsNo2/"/>
      <url>/rainbow-bubbles/IELTS/rootsNo2/</url>
      
        <content type="html"><![CDATA[<h1 id="5个常用的词根"><a href="#5个常用的词根" class="headerlink" title="5个常用的词根"></a>5个常用的词根</h1><p>介绍5个常用的词根，会介绍他们的来源，意思，读音以及例子。帮组我们记忆英语单词。</p><h2 id="No-1-scribe-script"><a href="#No-1-scribe-script" class="headerlink" title="No.1 scribe &#x2F; script"></a>No.1 scribe &#x2F; script</h2><h3 id="1-来源"><a href="#1-来源" class="headerlink" title="1. 来源"></a>1. 来源</h3><ul><li>来自拉丁语动词 <strong>scribere</strong>，意思是 “<strong>to write</strong>”（写）。</li><li>原始拉丁拼写：<strong>scribere</strong>（发音大约为 <strong>&#x2F;ˈskriː.be.re&#x2F;</strong>）</li></ul><h3 id="2-词根含义"><a href="#2-词根含义" class="headerlink" title="2. 词根含义"></a>2. 词根含义</h3><ul><li><strong>scribe</strong> 的基本含义是：“<strong>写</strong>”。</li><li>它与“<strong>文字、记录、描述</strong>”有关。</li><li>变体词根还有 <strong>script</strong>（名词形式，意为“<strong>书写的东西</strong>”）</li></ul><h3 id="3-读音"><a href="#3-读音" class="headerlink" title="3. 读音"></a>3. 读音</h3><ul><li><strong>scribe</strong>：&#x2F;skraɪb&#x2F;</li><li><strong>script</strong>：&#x2F;skrɪpt&#x2F;</li></ul><h3 id="4-例词解析"><a href="#4-例词解析" class="headerlink" title="4. 例词解析"></a>4. 例词解析</h3><table><thead><tr><th>单词</th><th>构成</th><th>中文含义</th></tr></thead><tbody><tr><td><strong>describe</strong></td><td>de（向下）+ scribe（写）</td><td>描述</td></tr><tr><td><strong>prescribe</strong></td><td>pre（在前）+ scribe（写）</td><td>开药方；规定</td></tr><tr><td><strong>subscribe</strong></td><td>sub（在下面）+ scribe</td><td>订阅，签署</td></tr><tr><td><strong>transcribe</strong></td><td>trans（转移）+ scribe</td><td>抄写，转录</td></tr><tr><td><strong>inscribe</strong></td><td>in（里面）+ s</td><td></td></tr></tbody></table><h3 id="5-记忆小技巧"><a href="#5-记忆小技巧" class="headerlink" title="5. 记忆小技巧"></a>5. 记忆小技巧</h3><ul><li><strong>scribe</strong> &#x3D; 写：想象成“scribe 用羽毛笔在羊皮纸上书写”</li><li><strong>script</strong> &#x3D; 写下的东西：如电影剧本、医生开的处方、附言（P.S.）</li></ul><h2 id="No-2-norm"><a href="#No-2-norm" class="headerlink" title="No.2 norm"></a>No.2 norm</h2><h3 id="1-来源-1"><a href="#1-来源-1" class="headerlink" title="1. 来源"></a>1. 来源</h3><ul><li>自拉丁语 norma，意为：木匠用来测直的“<strong>角尺</strong>”，引申为“<strong>准则、规范</strong>”</li><li>后来演变为现代英语中表达“<strong>规则</strong>”“<strong>正常</strong>”“<strong>标准</strong>”的一系列词汇。</li></ul><h3 id="2-词根含义-1"><a href="#2-词根含义-1" class="headerlink" title="2. 词根含义"></a>2. 词根含义</h3><ul><li>原始含义“<strong>直尺；标准；规则</strong>”</li></ul><h3 id="3-发音"><a href="#3-发音" class="headerlink" title="3. 发音"></a>3. 发音</h3><p>norm：&#x2F;nɔːrm&#x2F;</p><h3 id="4-例词解析-1"><a href="#4-例词解析-1" class="headerlink" title="4. 例词解析"></a>4. 例词解析</h3><table><thead><tr><th>单词</th><th>构成结构</th><th>中文含义</th></tr></thead><tbody><tr><td><strong>norm</strong></td><td>norm</td><td>常规；标准；规范</td></tr><tr><td><strong>normal</strong></td><td>norm（标准）+ -al（形容词后缀）</td><td>正常的，标准的</td></tr><tr><td><strong>abnormal</strong></td><td>ab（离开）+ norm（标准）</td><td>反常的，异常的</td></tr><tr><td><strong>enormous</strong></td><td>e（出）+ norm（规则）</td><td>巨大的（超出常规）</td></tr><tr><td><strong>normalize</strong></td><td>norm（标准）+ -ize（使…化）</td><td>正常化，使标准化</td></tr><tr><td><strong>subnormal</strong></td><td>sub（低于）+ norm（标准）</td><td>低于正常的</td></tr></tbody></table><h3 id="5-记忆小技巧-1"><a href="#5-记忆小技巧-1" class="headerlink" title="5. 记忆小技巧"></a>5. 记忆小技巧</h3><ul><li><strong>norm &#x3D; standard</strong>（标准）想象成一把“尺子”，它衡量什么是“正常”。</li><li><strong>abnormal &#x3D; 离开标准的 → 异常的</strong></li></ul><h2 id="No-3-view"><a href="#No-3-view" class="headerlink" title="No.3 view"></a>No.3 view</h2><h3 id="1-来源-2"><a href="#1-来源-2" class="headerlink" title="1. 来源"></a>1. 来源</h3><ul><li>来自拉丁语 <strong>videre</strong>，意思是“to see（看见）”</li><li>词根变形有：<ul><li>vid（如 video）</li><li>vis（如 visual）</li><li>view（法语借词形式）</li></ul></li></ul><h3 id="2-词根含义-2"><a href="#2-词根含义-2" class="headerlink" title="2. 词根含义"></a>2. 词根含义</h3><ul><li>原始含义“<strong>看、看见</strong>”</li><li>英文含义<strong>see, look, observe</strong>（看）</li></ul><h3 id="3-发音-1"><a href="#3-发音-1" class="headerlink" title="3. 发音"></a>3. 发音</h3><ul><li>view：&#x2F;vjuː&#x2F;</li></ul><h3 id="4-例词解析-2"><a href="#4-例词解析-2" class="headerlink" title="4. 例词解析"></a>4. 例词解析</h3><table><thead><tr><th>单词</th><th>构成结构</th><th>中文含义</th></tr></thead><tbody><tr><td><strong>view</strong></td><td>view</td><td>视野；看法</td></tr><tr><td><strong>review</strong></td><td>re（再次）+ view</td><td>复习，回顾；评论</td></tr><tr><td><strong>preview</strong></td><td>pre（在前）+ view</td><td>预览，预告片</td></tr><tr><td><strong>interview</strong></td><td>inter（互相）+ view</td><td>面试，访谈</td></tr><tr><td><strong>overview</strong></td><td>over（全面）+ view</td><td>概览，概况</td></tr><tr><td><strong>supervise</strong></td><td>super（在上）+ vis（看）</td><td>监督（&#x3D; 从上面看）</td></tr><tr><td><strong>vision</strong></td><td>vis（看）+ -ion（名词）</td><td>视力，视野，想象力</td></tr><tr><td><strong>television</strong></td><td>tele（远）+ vis（看）</td><td>电视（远距离观看）</td></tr></tbody></table><h3 id="5-记忆小技巧-2"><a href="#5-记忆小技巧-2" class="headerlink" title="5. 记忆小技巧"></a>5. 记忆小技巧</h3><p><strong>view</strong> &#x3D; 看：你看到的就是你的 view（视野、观点）<br><strong>review</strong> &#x3D; 再次看 → 复习、评论<br><strong>interview</strong> &#x3D; 互相看 → 面试时彼此观察了解</p><h2 id="No-4-press"><a href="#No-4-press" class="headerlink" title="No.4 press"></a>No.4 press</h2><h3 id="1-来源-3"><a href="#1-来源-3" class="headerlink" title="1. 来源"></a>1. 来源</h3><ul><li>来自拉丁语 <strong>premere</strong>，意为 “<strong>to press down</strong>”（向下压）</li><li>后来进入古法语为 <strong>presser</strong>，再传入英语</li><li>英语中的 <strong>press</strong> 既可以做动词（按压），也能做名词（印刷、新闻界）</li></ul><h3 id="2-含义"><a href="#2-含义" class="headerlink" title="2. 含义"></a>2. 含义</h3><p>原始含义“<strong>压，挤</strong>”</p><h3 id="3-发音-2"><a href="#3-发音-2" class="headerlink" title="3. 发音"></a>3. 发音</h3><p>press：&#x2F;pres&#x2F;</p><h3 id="4-常见单词例子"><a href="#4-常见单词例子" class="headerlink" title="4. 常见单词例子"></a>4. 常见单词例子</h3><table><thead><tr><th>单词</th><th>构成结构</th><th>中文含义</th></tr></thead><tbody><tr><td><strong>press</strong></td><td>press</td><td>按，压；印刷；新闻界</td></tr><tr><td><strong>pressure</strong></td><td>press + -ure（名词后缀）</td><td>压力</td></tr><tr><td><strong>express</strong></td><td>ex（向外）+ press</td><td>表达；快递</td></tr><tr><td><strong>impress</strong></td><td>im（向内）+ press</td><td>使印象深刻</td></tr><tr><td><strong>suppress</strong></td><td>sub（在下）+ press</td><td>镇压，压制</td></tr><tr><td><strong>oppress</strong></td><td>ob（反）+ press</td><td>压迫，压制</td></tr><tr><td><strong>depress</strong></td><td>de（向下）+ press</td><td>使沮丧；经济下行</td></tr><tr><td><strong>compress</strong></td><td>com（共同）+ press</td><td>压缩</td></tr><tr><td><strong>repress</strong></td><td>re（回）+ press</td><td>抑制，压抑</td></tr></tbody></table><h3 id="5-记忆小技巧-3"><a href="#5-记忆小技巧-3" class="headerlink" title="5. 记忆小技巧"></a>5. 记忆小技巧</h3><ul><li>press &#x3D; 压：想象一个人用手去“压按钮”</li><li>express &#x3D; 往外压出 → 表达、表现</li><li>suppress &#x3D; 向下压 → 镇压</li><li>depress &#x3D; 向下压情绪 → 沮丧</li></ul><h2 id="No-5-serve"><a href="#No-5-serve" class="headerlink" title="No.5 serve"></a>No.5 serve</h2><h3 id="1-来源-4"><a href="#1-来源-4" class="headerlink" title="1. 来源"></a>1. 来源</h3><ul><li>来自拉丁语 <strong>servire</strong>：意为“<strong>to be a servant</strong>”（做仆人）</li><li>由名词 <strong>servus</strong>（奴仆）演变而来</li><li>在英语中保留了“<strong>服务、服侍、为他人工作</strong>”的核心含义</li></ul><h3 id="2-含义-1"><a href="#2-含义-1" class="headerlink" title="2. 含义"></a>2. 含义</h3><p>原始含义“<strong>做仆人，服务</strong>”</p><h3 id="3-发音-3"><a href="#3-发音-3" class="headerlink" title="3. 发音"></a>3. 发音</h3><p><strong>serve</strong>：&#x2F;sɜːrv&#x2F;</p><h3 id="4-常见单词例子-1"><a href="#4-常见单词例子-1" class="headerlink" title="4. 常见单词例子"></a>4. 常见单词例子</h3><table><thead><tr><th>单词</th><th>构成结构</th><th>中文含义</th></tr></thead><tbody><tr><td><strong>serve</strong></td><td>serve</td><td>服务；端上；服役</td></tr><tr><td><strong>service</strong></td><td>serve + -ice（名词后缀）</td><td>服务；服务行业</td></tr><tr><td><strong>servant</strong></td><td>serve + -ant（人）</td><td>仆人</td></tr><tr><td><strong>deserve</strong></td><td>de（加强）+ serve</td><td>值得；应得</td></tr><tr><td><strong>preserve</strong></td><td>pre（提前）+ serve</td><td>保护；保存</td></tr><tr><td><strong>conserve</strong></td><td>con（共同）+ serve</td><td>节约，保存</td></tr><tr><td><strong>observe</strong></td><td>ob（朝向）+ serve</td><td>观察</td></tr><tr><td><strong>reserve</strong></td><td>re（回）+ serve</td><td>保留；预订</td></tr><tr><td><strong>subservient</strong></td><td>sub（在下面）+ serve + -ient</td><td>屈从的；卑躬屈膝的</td></tr></tbody></table><h3 id="5-记忆小技巧-4"><a href="#5-记忆小技巧-4" class="headerlink" title="5. 记忆小技巧"></a>5. 记忆小技巧</h3><ul><li><strong>serve</strong> &#x3D; 服务：想象一个服务员在端盘子</li><li><strong>reserve</strong> &#x3D; 服务回来 → 保留、预订</li><li><strong>deserve</strong> &#x3D; 服务值得 → 应得</li><li><strong>preserve</strong> &#x3D; 提前服务 → 保存（保护）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 英语学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> roots </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用词根（roots）第一篇</title>
      <link href="/rainbow-bubbles/IELTS/roots%E7%AC%AC%E4%B8%80%E7%AF%87/"/>
      <url>/rainbow-bubbles/IELTS/roots%E7%AC%AC%E4%B8%80%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="5个常用的词根"><a href="#5个常用的词根" class="headerlink" title="5个常用的词根"></a>5个常用的词根</h1><p>介绍5个常用的词根，会介绍他们的来源，意思，读音以及例子。帮组我们记忆英语单词。</p><h2 id="No-1-pos"><a href="#No-1-pos" class="headerlink" title="No.1 pos"></a>No.1 pos</h2><h3 id="1-来源"><a href="#1-来源" class="headerlink" title="1. 来源"></a>1. 来源</h3><ul><li><strong>pos</strong> 来源于拉丁语动词 <strong>“ponere”</strong>，意思是 “<strong>放置、摆放</strong>”。</li><li>英语中的许多单词，都是从这个拉丁词根演变而来。</li><li>常见变形：pos, pon, pose, posit</li></ul><h3 id="2-词根含义"><a href="#2-词根含义" class="headerlink" title="2. 词根含义"></a>2. 词根含义</h3><ul><li><strong>pos &#x2F; pon &#x2F; posit</strong> → 表示 “<strong>放、置</strong>”</li><li>它们是同一个词根的不同形式，在不同单词中以不同拼写出现，但含义一致。</li></ul><h3 id="3-发音"><a href="#3-发音" class="headerlink" title="3. 发音"></a>3. 发音</h3><ul><li><strong>pos</strong> &#x2F;pɒs&#x2F;（英）或 &#x2F;pɑːs&#x2F;（美）</li><li>这个词根在单词中不总是单独读作 “pos”，但常保留字母形式。例如：position（pə-ˈzɪʃ-ən）</li></ul><h3 id="4-例词解析"><a href="#4-例词解析" class="headerlink" title="4. 例词解析"></a>4. 例词解析</h3><table><thead><tr><th>单词</th><th>构成</th><th>含义</th></tr></thead><tbody><tr><td><strong>position</strong></td><td>posit（放）+ ion（名词）</td><td>位置，职位</td></tr><tr><td><strong>positive</strong></td><td>posit（放）+ ive（形容词）</td><td>肯定的，积极的</td></tr><tr><td><strong>deposit</strong></td><td>de（向下）+ posit（放）</td><td>存款，沉积</td></tr><tr><td><strong>compose</strong></td><td>com（一起）+ pose（放）</td><td>组成，作曲</td></tr><tr><td><strong>oppose</strong></td><td>ob（对面）+ pose（放）</td><td>反对</td></tr><tr><td><strong>expose</strong></td><td>ex（向外）+ pose（放）</td><td>暴露</td></tr><tr><td><strong>propose</strong></td><td>pro（向前）+ pose（放）</td><td>提议，求婚</td></tr><tr><td><strong>impose</strong></td><td>im（进入）+ pose（放）</td><td>强加</td></tr></tbody></table><h3 id="5-小技巧：记忆关键词"><a href="#5-小技巧：记忆关键词" class="headerlink" title="5. 小技巧：记忆关键词"></a>5. 小技巧：记忆关键词</h3><ul><li><strong>pose</strong>：放</li><li>想象：你把一个东西“放”（pose）在某个地方，放在哪儿 → 就是 <strong>position</strong></li><li>向下放 → <strong>deposit</strong></li><li>一起放 → <strong>compose</strong></li><li>向外放 → <strong>expose</strong></li></ul><h2 id="No-2-form"><a href="#No-2-form" class="headerlink" title="No.2 form"></a>No.2 form</h2><h3 id="1-来源-1"><a href="#1-来源-1" class="headerlink" title="1. 来源"></a>1. 来源</h3><ul><li>来自拉丁语 “<strong>forma</strong>“，意思是 “<strong>形状，形式，外形</strong>”。</li><li>它在英语中被大量使用，常作为词根出现，表达“形成、形状、结构”的意思。</li><li>常见变形：<strong>form, format, forme</strong></li></ul><h3 id="2-词根含义-1"><a href="#2-词根含义-1" class="headerlink" title="2. 词根含义"></a>2. 词根含义</h3><ul><li>form 表示：形状、形成、构造</li><li>用于表示 <strong>外形、结构、组织方式</strong> 等意义，也可引申为 <strong>使成形、塑造、建立</strong>。</li></ul><h3 id="3-发音-1"><a href="#3-发音-1" class="headerlink" title="3. 发音"></a>3. 发音</h3><p>form &#x2F;fɔːm&#x2F;（英）或 &#x2F;fɔːrm&#x2F;（美）</p><h3 id="4-例词解析-1"><a href="#4-例词解析-1" class="headerlink" title="4.  例词解析"></a>4.  例词解析</h3><table><thead><tr><th>单词</th><th>构成</th><th>含义</th></tr></thead><tbody><tr><td><strong>form</strong></td><td>form（形）</td><td>形式，表格，形成</td></tr><tr><td><strong>inform</strong></td><td>in（进入）+ form（形）</td><td>通知，使了解（进入某种“意识形态”）</td></tr><tr><td><strong>reform</strong></td><td>re（重新）+ form（形）</td><td>改革，改造</td></tr><tr><td><strong>transform</strong></td><td>trans（改变）+ form（形）</td><td>转变，变形</td></tr><tr><td><strong>conform</strong></td><td>con（共同）+ form（形）</td><td>遵从，一致</td></tr><tr><td><strong>perform</strong></td><td>per（完全）+ form（形）</td><td>表演，执行</td></tr><tr><td><strong>deform</strong></td><td>de（去除，坏）+ form（形）</td><td>使变形，畸形</td></tr><tr><td><strong>uniform</strong></td><td>uni（统一）+ form（形）</td><td>制服，一致的</td></tr></tbody></table><h3 id="5-小技巧：词根联想记忆法"><a href="#5-小技巧：词根联想记忆法" class="headerlink" title="5.  小技巧：词根联想记忆法"></a>5.  小技巧：词根联想记忆法</h3><p>form &#x3D; 形状 →</p><ul><li>改变形状：transform</li><li>重新做形状：reform</li><li>一样的形状：uniform</li><li>不正常的形状：deform</li></ul><h2 id="No-3-press"><a href="#No-3-press" class="headerlink" title="No.3 press"></a>No.3 press</h2><h3 id="1-来源-2"><a href="#1-来源-2" class="headerlink" title="1. 来源"></a>1. 来源</h3><ul><li><strong>press</strong> 来自拉丁语 “<strong>premere</strong>“，意思是：“压、挤”。</li><li>这个词根在英语中保留了“施加压力、推动”的核心含义。</li><li>常见变形：<strong>press, -pressur-, -pression</strong></li></ul><h3 id="2-词根含义-2"><a href="#2-词根含义-2" class="headerlink" title="2. 词根含义"></a>2. 词根含义</h3><p><strong>press &#x2F; -press &#x2F; -pressur-</strong><br>→ 意为 压、挤、逼迫、推动</p><h3 id="3-发音-2"><a href="#3-发音-2" class="headerlink" title="3. 发音"></a>3. 发音</h3><p>press &#x2F;pres&#x2F;<br>（简洁有力，和“压”这个含义非常贴切）</p><h3 id="4-常见单词例子"><a href="#4-常见单词例子" class="headerlink" title="4.  常见单词例子"></a>4.  常见单词例子</h3><table><thead><tr><th>单词</th><th>构成</th><th>含义</th></tr></thead><tbody><tr><td><strong>press</strong></td><td>press（压）</td><td>按压、新闻、出版社</td></tr><tr><td><strong>pressure</strong></td><td>press（压）+ ure（名词后缀）</td><td>压力、压迫</td></tr><tr><td><strong>impress</strong></td><td>im（进入）+ press（压）</td><td>留下印象、感动</td></tr><tr><td><strong>express</strong></td><td>ex（向外）+ press（压）</td><td>表达、快递</td></tr><tr><td><strong>suppress</strong></td><td>sup（下）+ press（压）</td><td>镇压、抑制</td></tr><tr><td><strong>oppress</strong></td><td>ob（反对）+ press（压）</td><td>压迫、欺压</td></tr><tr><td><strong>depress</strong></td><td>de（向下）+ press（压）</td><td>使沮丧、使下沉</td></tr><tr><td><strong>compress</strong></td><td>com（一起）+ press（压）</td><td>压缩、精简</td></tr><tr><td><strong>repress</strong></td><td>re（再次）+ press（压）</td><td>压制、抑制（情感、冲动）</td></tr></tbody></table><h3 id="5-小技巧：词根联想法"><a href="#5-小技巧：词根联想法" class="headerlink" title="5.  小技巧：词根联想法"></a>5.  小技巧：词根联想法</h3><p>想象一个“压力机”在压东西——</p><ul><li>向外压：<strong>express</strong>（表达、表现）</li><li>向下压：<strong>depress</strong>（压抑、使沮丧）</li><li>再次压：<strong>repress</strong>（压制情绪）</li><li>一起压：<strong>compress</strong>（压缩）</li></ul><h2 id="No-4-duce"><a href="#No-4-duce" class="headerlink" title="No.4 duce"></a>No.4 duce</h2><h3 id="1-来源-3"><a href="#1-来源-3" class="headerlink" title="1. 来源"></a>1. 来源</h3><ul><li><strong>duce</strong> 来自拉丁语动词 “<strong>ducere</strong>“，意思是：“<strong>引导、带来、领导</strong>”</li><li>它是很多英语单词的核心词根，表示“引导、领导、带向”的含义</li><li>常见变形：<strong>duce, duct, duction</strong> 等</li></ul><h3 id="2-词根含义-3"><a href="#2-词根含义-3" class="headerlink" title="2. 词根含义"></a>2. 词根含义</h3><ul><li><strong>duce &#x2F; duct</strong> → 意为 引导、拉、带领</li><li>在不同单词中会出现不同形式：<strong>duce, duct, duce, duction</strong></li></ul><h3 id="3-发音-3"><a href="#3-发音-3" class="headerlink" title="3. 发音"></a>3. 发音</h3><ul><li><strong>duce</strong> &#x2F;djuːs&#x2F; 或 &#x2F;duːs&#x2F;</li><li><strong>duct</strong> &#x2F;dʌkt&#x2F;</li></ul><h3 id="4-常见单词例子-1"><a href="#4-常见单词例子-1" class="headerlink" title="4.  常见单词例子"></a>4.  常见单词例子</h3><table><thead><tr><th>单词</th><th>构成</th><th>含义</th></tr></thead><tbody><tr><td><strong>introduce</strong></td><td>intro（向内）+ duce（引导）</td><td>介绍，引入</td></tr><tr><td><strong>produce</strong></td><td>pro（向前）+ duce（引导）</td><td>生产，制造</td></tr><tr><td><strong>reduce</strong></td><td>re（向后）+ duce（引导）</td><td>减少，降低</td></tr><tr><td><strong>educate</strong></td><td>e（向外）+ duce（引导）</td><td>教育（把潜力引导出来）</td></tr><tr><td><strong>conduct</strong></td><td>con（一起）+ duct（引导）</td><td>指导，指挥，传导</td></tr><tr><td><strong>deduce</strong></td><td>de（向下）+ duce（引导）</td><td>推断，演绎</td></tr><tr><td><strong>induce</strong></td><td>in（向内）+ duce（引导）</td><td>引诱，促使</td></tr><tr><td><strong>abduct</strong></td><td>ab（离开）+ duct（带走）</td><td>绑架，诱拐</td></tr></tbody></table><h3 id="5-小技巧：图像记忆"><a href="#5-小技巧：图像记忆" class="headerlink" title="5.  小技巧：图像记忆"></a>5.  小技巧：图像记忆</h3><p>想象 <strong>duce &#x3D; 带路的人</strong></p><ul><li>带你进入：<strong>introduce</strong></li><li>带你走远一点：<strong>reduce</strong></li><li>把你带出来成长：<strong>educate</strong></li><li>共同引导：<strong>conduct</strong></li></ul><h2 id="No-5-gress"><a href="#No-5-gress" class="headerlink" title="No.5 gress"></a>No.5 gress</h2><h3 id="1-来源-4"><a href="#1-来源-4" class="headerlink" title="1. 来源"></a>1. 来源</h3><ul><li><strong>gress</strong> 来自拉丁语 “<strong>gradi</strong>“，意为 “<strong>走、步行</strong>”</li><li>它的名词形式 “<strong>gressus</strong>” 表示 “<strong>一步、步伐</strong>”，因此英语中带有 <strong>gress</strong> 的单词都与 “<strong>走、前进</strong>” 有关。</li><li>常见变形：<strong>gress, grad, grade</strong></li></ul><h3 id="2-词根含义-4"><a href="#2-词根含义-4" class="headerlink" title="2. 词根含义"></a>2. 词根含义</h3><ul><li><strong>gress</strong>（动）&#x2F; <strong>grad</strong>（形）<br>→ 表示 “<strong>走、步、前进</strong>”</li><li>常用于描述<strong>进步、退步、过程、等级变化</strong>等</li></ul><h3 id="3-发音-4"><a href="#3-发音-4" class="headerlink" title="3. 发音"></a>3. 发音</h3><p><strong>gress &#x2F;ɡres&#x2F;</strong> 读音简洁有力，就像“步伐”一样。</p><h3 id="4-常见单词例子-2"><a href="#4-常见单词例子-2" class="headerlink" title="4.  常见单词例子"></a>4.  常见单词例子</h3><table><thead><tr><th>单词</th><th>构成</th><th>含义</th></tr></thead><tbody><tr><td><strong>progress</strong></td><td>pro（向前）+ gress（走）</td><td>前进，进步</td></tr><tr><td><strong>regress</strong></td><td>re（向后）+ gress（走）</td><td>退步，倒退</td></tr><tr><td><strong>congress</strong></td><td>con（一起）+ gress（走）</td><td>国会（大家走到一起讨论）</td></tr><tr><td><strong>digress</strong></td><td>di（离开）+ gress（走）</td><td>离题，跑题</td></tr><tr><td><strong>aggress</strong></td><td>ag（&#x3D;ad，向）+ gress（走）</td><td>侵犯，攻击（走向别人）</td></tr><tr><td><strong>egress</strong></td><td>e（向外）+ gress（走）</td><td>出口，离开</td></tr><tr><td><strong>ingress</strong></td><td>in（向内）+ gress（走）</td><td>入口，进入</td></tr><tr><td><strong>transgress</strong></td><td>trans（穿越）+ gress（走）</td><td>违反，越界（走过界限）</td></tr></tbody></table><h3 id="5-小技巧：词根联想法-1"><a href="#5-小技巧：词根联想法-1" class="headerlink" title="5.  小技巧：词根联想法"></a>5.  小技巧：词根联想法</h3><p>把 <strong>gress</strong> 想象成 “<strong>行走、步伐</strong>”：</p><ul><li>向前走：<strong>progress</strong></li><li>向后走：<strong>digress</strong></li><li>离开主题走远：<strong>digress</strong></li><li>走出门：<strong>egress</strong></li><li>走进去：<strong>ingress</strong></li><li>越线走：<strong>transgress</strong></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上面介绍了五个词根，下面这一段帮助记忆。<br><strong>Form</strong> 是形，<strong>Press</strong> 是压，<br><strong>Duce</strong> 引导带大家；<br><strong>Gress</strong> 向前走步伐，<br><strong>Pos</strong> 是位置摆得佳！</p>]]></content>
      
      
      <categories>
          
          <category> 英语学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> roots </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Prefix &amp; roots &amp; suffix</title>
      <link href="/rainbow-bubbles/IELTS/Prefix-roots-suffix/"/>
      <url>/rainbow-bubbles/IELTS/Prefix-roots-suffix/</url>
      
        <content type="html"><![CDATA[<h1 id="前缀、词根和后缀介绍"><a href="#前缀、词根和后缀介绍" class="headerlink" title="前缀、词根和后缀介绍"></a>前缀、词根和后缀介绍</h1><p>在学习英语单词时，**掌握前缀（prefix）、词根（root）和后缀（suffix）**是非常有效的方法。它们是构成单词的三大要素，像拼积木一样，把意思组合在一起。通过了解这些组成部分，你可以轻松猜出不认识的单词含义，提高记忆效率。有点类似于汉字中的偏旁部首。</p><h2 id="一、什么是词根（Root）？"><a href="#一、什么是词根（Root）？" class="headerlink" title="一、什么是词根（Root）？"></a>一、什么是词根（Root）？</h2><p>词根是单词的<strong>核心部分</strong>，表示最基本的意思。许多英语词根来自<strong>拉丁语</strong>和<strong>希腊语</strong>。</p><p>常见词根及例句:</p><table><thead><tr><th>词根</th><th>含义</th><th>例词</th></tr></thead><tbody><tr><td><strong>port</strong></td><td>携带、运输</td><td>transport（运输），import（进口）</td></tr><tr><td><strong>scrib&#x2F;script</strong></td><td>写</td><td>describe（描述），script（剧本）</td></tr><tr><td><strong>spect</strong></td><td>看</td><td>inspect（检查），respect（尊敬）</td></tr><tr><td><strong>dict</strong></td><td>说</td><td>predict（预言），dictionary（词典）</td></tr><tr><td><strong>tele</strong></td><td>远</td><td>telephone（电话），television（电视）</td></tr><tr><td><strong>cred</strong></td><td>相信</td><td>credible（可信的），incredible（难以置信的）</td></tr></tbody></table><h2 id="二、什么是前缀（Prefix）？"><a href="#二、什么是前缀（Prefix）？" class="headerlink" title="二、什么是前缀（Prefix）？"></a>二、什么是前缀（Prefix）？</h2><p>前缀加在词根<strong>前面</strong>，用来改变词义，常表示“否定、方向、数量、时间”等意思。</p><p>常见前缀及例词：</p><table><thead><tr><th>前缀</th><th>含义</th><th>例词</th></tr></thead><tbody><tr><td><strong>un-</strong></td><td>否定（不）</td><td>unhappy（不快乐的），unknown（未知的）</td></tr><tr><td><strong>re-</strong></td><td>再，反复</td><td>rewrite（重写），return（返回）</td></tr><tr><td><strong>pre-</strong></td><td>之前</td><td>preview（预览），prepare（准备）</td></tr><tr><td><strong>dis-</strong></td><td>否定，分开</td><td>dislike（不喜欢），disconnect（断开）</td></tr><tr><td><strong>in- &#x2F; im-</strong></td><td>否定（不）</td><td>incorrect（不正确的），impossible（不可能的）</td></tr></tbody></table><h2 id="三、什么是后缀（Suffix）？"><a href="#三、什么是后缀（Suffix）？" class="headerlink" title="三、什么是后缀（Suffix）？"></a>三、什么是后缀（Suffix）？</h2><p>后缀加在词根<strong>后面</strong>，通常用来<strong>改变词性</strong>（例如：名词→形容词、动词→名词）。</p><p>常见后缀及例词：</p><table><thead><tr><th>后缀</th><th>用途</th><th>例词</th></tr></thead><tbody><tr><td><strong>-er &#x2F; -or</strong></td><td>表示“人”</td><td>teacher（教师），actor（演员）</td></tr><tr><td><strong>-able &#x2F; -ible</strong></td><td>能…的</td><td>readable（可读的），visible（可见的）</td></tr><tr><td><strong>-ment</strong></td><td>表示名词（行为结果）</td><td>development（发展），improvement（改善）</td></tr><tr><td><strong>-ness</strong></td><td>名词，表示状态</td><td>kindness（善良），happiness（幸福）</td></tr><tr><td><strong>-ly</strong></td><td>副词（方式）</td><td>quickly（快速地），softly（柔和地）</td></tr></tbody></table><h2 id="四、实际例子分析"><a href="#四、实际例子分析" class="headerlink" title="四、实际例子分析"></a>四、实际例子分析</h2><ol><li><p><strong>Unbelievable</strong><br><strong>un</strong>-（不）+ <strong>believe</strong>（相信）+ -<strong>able</strong>（能…的）<br>→ 不可置信的</p></li><li><p><strong>Transportation</strong><br><strong>trans</strong>-（跨越）+ <strong>port</strong>（运输）+ -<strong>ation</strong>（名词后缀）<br>→ 运输、交通</p></li><li><p>Misunderstand<br><strong>mis</strong>-（错误地）+ <strong>understand</strong>（理解）<br>→ 误解</p></li></ol><h2 id="五、学习建议"><a href="#五、学习建议" class="headerlink" title="五、学习建议"></a>五、学习建议</h2><ul><li>学习常见词根、前缀和后缀，积累构词知识。</li><li>遇到生词时试着<strong>拆解</strong>：<strong>前缀</strong> + <strong>词根</strong> + <strong>后缀</strong></li><li>做笔记，把词汇分组记忆，比如所有含有“spect（看）”的单词放在一起。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><table><thead><tr><th>组成部分</th><th>作用</th><th>例子</th></tr></thead><tbody><tr><td>前缀</td><td>改变意义</td><td><strong>un</strong>happy, <strong>re</strong>view</td></tr><tr><td>词根</td><td>表示基本意思</td><td><strong>port</strong>, <strong>scrib</strong>, <strong>cred</strong></td></tr><tr><td>后缀</td><td>改变词性</td><td>teach<strong>er</strong>, kind<strong>ness</strong></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 英语学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> prefix </tag>
            
            <tag> roots </tag>
            
            <tag> suffix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代孕：一种社会趋势下的个体选择，而非道德灾难</title>
      <link href="/rainbow-bubbles/News/%E7%83%AD%E7%82%B9%E8%AF%9D%E9%A2%98%E5%85%B3%E4%BA%8E%E4%BB%A3%E5%AD%95%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A7%82%E7%82%B9/"/>
      <url>/rainbow-bubbles/News/%E7%83%AD%E7%82%B9%E8%AF%9D%E9%A2%98%E5%85%B3%E4%BA%8E%E4%BB%A3%E5%AD%95%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A7%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="代孕：一种社会趋势下的个体选择，而非道德灾难"><a href="#代孕：一种社会趋势下的个体选择，而非道德灾难" class="headerlink" title="代孕：一种社会趋势下的个体选择，而非道德灾难"></a>代孕：一种社会趋势下的个体选择，而非道德灾难</h1><p>在关于代孕的讨论中，常见的反对声音大多聚焦于伦理风险、母体安全、孩子的幸福以及社会结构的“破坏”。而我认为，这些担忧背后，其实隐藏着一种“传统观念尚未适应社会变迁”的惯性思维。</p><p>我的观点是：<strong>代孕确实带来挑战，但它本质上并不是问题的制造者，而是社会深层转型中的一个结果。</strong></p><h2 id="一、对女性身体的风险：应归为医疗和制度问题"><a href="#一、对女性身体的风险：应归为医疗和制度问题" class="headerlink" title="一、对女性身体的风险：应归为医疗和制度问题"></a>一、对女性身体的风险：应归为医疗和制度问题</h2><p>代孕是否比自然分娩更危险？从医学角度看，两者本质上是一种过程差异，而非本质不同。风险的控制能力更多取决于<strong>医疗保障系统</strong>和<strong>代孕流程的规范化</strong>，而不是代孕本身。</p><p>现代医疗手段已大幅提高了妊娠安全性。只要是在合法、可控的医疗体系内操作，女性的身体风险是<strong>可预测、可管理的</strong>。因此，把“风险”归咎于“代孕”本身，是模糊焦点的说法。</p><h2 id="二、心理创伤：并非代孕所独有"><a href="#二、心理创伤：并非代孕所独有" class="headerlink" title="二、心理创伤：并非代孕所独有"></a>二、心理创伤：并非代孕所独有</h2><p>“代孕可能对代母造成心理创伤”是常见担忧之一。但事实上，产后抑郁、情感波动，也广泛存在于自然怀孕中。情感的体验是个体的，不应因其在代孕中出现，就被视为“代孕的特殊恶果”。</p><p>是否产生创伤，更多取决于<strong>代母是否被尊重、是否有心理支持系统</strong>、是否出于自愿。这些因素在所有人类服务行为中都应当被重视，而不是仅在代孕中被单独放大。</p><h2 id="三、剥削问题：根源是人性和制度，而非代孕"><a href="#三、剥削问题：根源是人性和制度，而非代孕" class="headerlink" title="三、剥削问题：根源是人性和制度，而非代孕"></a>三、剥削问题：根源是人性和制度，而非代孕</h2><p>有人批评代孕产业化会剥削贫困女性。但这类剥削行为，<strong>并不是代孕特有</strong>。只要存在劳务交易关系——从快递员、外卖员到工厂工人，都有可能面临不平等。</p><p>关键是：<strong>是否自愿、是否知情、是否有保障？</strong><br>只要建立合理的法律框架、医疗监管和权益保障机制，代孕完全可以是一个合法合规、有尊严的选择。</p><p>将所有代孕行为一律打成“剥削”，反而会遮蔽真正需要规制的问题，并剥夺了一些女性自我决定身体与命运的权利。</p><h2 id="四、孩子的权利与幸福：关键是成长环境，而非出生方式"><a href="#四、孩子的权利与幸福：关键是成长环境，而非出生方式" class="headerlink" title="四、孩子的权利与幸福：关键是成长环境，而非出生方式"></a>四、孩子的权利与幸福：关键是成长环境，而非出生方式</h2><p>一个孩子是否幸福，取决的不是他从谁身上出生，而是他在怎样的环境中成长。有文化、有经济能力、有道德信仰的父母，无论是否通过代孕拥有孩子，都能提供良好的成长土壤。</p><p>相反，那些以“血缘”为名却忽视情感投入的原生家庭，也可能带来孩子的情感创伤。</p><p>在未来的社会中，“我是谁的孩子”不再是身份的核心，而“我是否被爱、被尊重地长大”才是更重要的命题。</p><h2 id="五、社会伦理结构：代孕不是破坏者，而是演变的参与者"><a href="#五、社会伦理结构：代孕不是破坏者，而是演变的参与者" class="headerlink" title="五、社会伦理结构：代孕不是破坏者，而是演变的参与者"></a>五、社会伦理结构：代孕不是破坏者，而是演变的参与者</h2><p>代孕确实会加速家庭结构的变化，比如淡化传统家族的血缘纽带。但这并不是“破坏”，而是<strong>社会从家族主义向个体主义转型的必然趋势。</strong></p><p>在现代社会，人们越来越重视个人生活质量、自我选择和尊严。就算没有代孕，这种价值观的变迁也在发生。代孕只是让一些原本难以实现的个体生活愿望变成了可能。</p><p>未来，人们更关心的是“我想过怎样的一生”，而不是“我是从哪里来的”。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>代孕不完美，它确实需要法律制度的进一步规范，也需要公众对新型伦理关系的理解和适应。但我们不能因为存在风险和个案滥用，就否定它为一部分人提供尊严与希望的价值。</p><p>与其简单否定，不如用理性和制度设计，去引导它成为一种<strong>更加人道、自由与公平的生育选择。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 生活日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 热点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL常见问题及处理</title>
      <link href="/rainbow-bubbles/Technology/MySQL%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E5%A4%84%E7%90%86/"/>
      <url>/rainbow-bubbles/Technology/MySQL%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h1><p>性能优秀主键所有速度快于其他索引，支持事务，支持行级锁</p><h1 id="MyISM"><a href="#MyISM" class="headerlink" title="MyISM"></a>MyISM</h1><p>不支持事务，支持表级锁</p><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><ol><li>大大减少服务器需要扫描的数据量</li><li>帮助服务器避免排序和临时表</li><li>将随即I&#x2F;O变顺序I&#x2F;O</li><li>大大提高查询速度，降低写速度，占用磁盘</li></ol><h2 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h2><p>主键索引，组合索引，唯一索引，普通索引</p><h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2><ol><li>索引列是出现在where子句 中的列，或连接子句中的列</li><li>索引列的基数越大效果越好</li><li>对字符串进行索引，应该制订一个前缀的长度，可以节省大量的索引空间</li><li>根据情况创建复合索引，</li><li>避免创建过多的索引</li><li>选择字节较短的列作为索引，离散度较高的列作为索引</li></ol><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol><li>A or B 两个列必须都有索引，才会用到索引</li><li>列类型的字符串查询时一定要加双引号，否则索引失效<br>eg:请描述创建组合索引的方案。</li></ol><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><ol><li>优化查询过程中的数据访问</li><li>优化长难的查询语句</li><li>优化特定类型的查询语句</li><li>分表</li></ol><h1 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> profiling <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">show</span> profiles</span><br><span class="line">explain</span><br></pre></td></tr></table></figure><h1 id="方案："><a href="#方案：" class="headerlink" title="方案："></a>方案：</h1><ol><li>多表关联查询指定查询列明（A.id，A.name）</li><li>查询数据量较多，使用limit解决</li><li>重复查询相同的数据，可以缓存数据，下次直接读取缓存</li><li>查询时是否在扫描额外的记录，如果存在就创建索引覆盖扫描</li><li>适当修改表的范式（第一，二，三范式）</li><li>尽可能的少查询请求（如果数据量很大，分解为多个查询也是有必要的）</li><li>count(<em>) 中的</em>会忽略所有的列，直接统计所有的列，因此不要使用count（列名）</li><li>关联查询时确定ON或者USING子句的列上有所以，避免全表扫描</li><li>groupBy和orderBy中只有一个表的列，这样mysql才有可能使用索引</li><li>如果不需要orderBy，进行groupBy时使用orderBy NULL，mysql不会在进行文件排序</li></ol><h1 id="安全："><a href="#安全：" class="headerlink" title="安全："></a>安全：</h1><p>sql注入</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">user</span><span class="operator">/</span><span class="keyword">delete</span><span class="operator">/</span>?id<span class="operator">=</span><span class="number">1</span> <span class="keyword">or</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span> <span class="keyword">or</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><ol><li>sql语句预处理（prepare）</li><li>写入数据库的数据进行特殊字符的转译</li><li>错误信息不要返回给用户，记录到错误日志</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis缓存穿透-缓存击穿-缓存雪崩-布隆过滤器</title>
      <link href="/rainbow-bubbles/Technology/Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F-%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF-%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
      <url>/rainbow-bubbles/Technology/Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F-%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF-%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h1><h2 id="缓存穿透-1"><a href="#缓存穿透-1" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>指在redis缓存中不存在数据，这个时候只能去访问持久层数据库，当用户很多时，缓存都没有命中就会照成很大压力</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol><li>布隆过滤器（对可能查询的数据先用hash存储）</li><li>缓存空对象：在没有的数据中存一个空，而这些空的对象会设置一个有效期）</li></ol><h1 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h1><p>缓存击穿指的是缓存中没有数据但数据库中有数据（一般是热点数据缓存时间到期），同一时间大量的并发请求由于读缓存没读到数据，就去数据库去取数据，导致某个时间内数据库压力剧增，导致崩溃。</p><h2 id="缓存击穿的解决方案"><a href="#缓存击穿的解决方案" class="headerlink" title="缓存击穿的解决方案"></a>缓存击穿的解决方案</h2><ol><li>设置热点数据永远不过期（可以判断当前key快要过期时，通过后台异步线程在重新构建缓存）</li><li>接口限流与熔断，降级。重要的接口一定要做好限流策略，防止用户恶意刷接口，同时要降级准备，当接口中的某些服务不可用时候，进行熔断，失败快速返回机制。</li><li>设置互斥锁。在并发的多个请求中，只有第一个请求线程能拿到锁并执行数据库查询操作，其他的线程拿不到锁就阻塞等着，等到第一个线程将数据写入缓存后，直接走缓存。<ul><li>就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db。</li><li>先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX）去set一个互斥锁。</li><li>当操作返回成功时，再进行load db的操作，并回设缓存,最后删除mutex key；</li><li>当操作返回失败，证明有线程在load db，当前线程睡眠一段时间再重试整个get缓存的方法。</li></ul></li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * redis </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@var</span> Redis </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="variable">$redis</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * id lenght</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@var</span> integer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="variable">$randomLen</span> = <span class="number">16</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * expire tolarance</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@var</span> integer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="variable">$tolerance</span> = <span class="number">500</span>; <span class="comment">// milliseconds</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * seconds to millis</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@var</span> integer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="variable">$millisPerSeconds</span> = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * set redis lua script </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@var</span> string</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="variable">$lockCommand</span> = <span class="string">&#x27;if redis.call(&quot;GET&quot;, KEYS[1]) == ARGV[1] then</span></span><br><span class="line"><span class="string">redis.call(&quot;SET&quot;, KEYS[1], ARGV[1], &quot;PX&quot;, ARGV[2])</span></span><br><span class="line"><span class="string">return &quot;OK&quot;</span></span><br><span class="line"><span class="string">else</span></span><br><span class="line"><span class="string">return redis.call(&quot;SET&quot;, KEYS[1], ARGV[1], &quot;NX&quot;, &quot;PX&quot;, ARGV[2])</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * get redis lua script</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@var</span> string</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="variable">$delCommand</span> = <span class="string">&#x27;if redis.call(&quot;GET&quot;, KEYS[1]) == ARGV[1] then</span></span><br><span class="line"><span class="string">    return redis.call(&quot;DEL&quot;, KEYS[1])</span></span><br><span class="line"><span class="string">else</span></span><br><span class="line"><span class="string">    return 0</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * lock key</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@var</span> string </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="variable">$key</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * lock id</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@var</span> [type]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="variable">$id</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * lock expire </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@var</span> integer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="variable">$seconds</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params">Redis <span class="variable">$redis</span>, <span class="keyword">string</span> <span class="variable">$key</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="variable language_">$this</span>-&gt;redis = <span class="variable">$redis</span>;</span><br><span class="line"><span class="variable language_">$this</span>-&gt;id = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">randomUUID</span>();</span><br><span class="line"><span class="variable language_">$this</span>-&gt;key = <span class="variable">$key</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * generate uuid </span></span><br><span class="line"><span class="comment"> * provisional way</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> string</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">randomUUID</span>(<span class="params"></span>): <span class="title">string</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="title function_ invoke__">substr</span>(<span class="title function_ invoke__">uniqid</span>(<span class="string">&#x27;&#x27;</span>, <span class="literal">true</span>), <span class="number">5</span>, <span class="variable">$this</span>-&gt;randomLen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * expire</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> integer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getPexpire</span>(<span class="params"></span>): <span class="title">int</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;seconds * <span class="variable language_">$this</span>-&gt;millisPerSeconds + <span class="variable language_">$this</span>-&gt;tolerance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * acquire lock </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">acquire</span>(<span class="params"></span>): <span class="title">bool</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="variable">$resp</span> = <span class="variable language_">$this</span>-&gt;redis-&gt;<span class="keyword">eval</span>(<span class="variable language_">$this</span>-&gt;lockCommand, [<span class="variable language_">$this</span>-&gt;key, <span class="variable language_">$this</span>-&gt;id, <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">getPexpire</span>()], <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$resp</span> == <span class="string">&#x27;OK&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * release lock </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">release</span>(<span class="params"></span>): <span class="title">bool</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="variable">$resp</span> = <span class="variable language_">$this</span>-&gt;redis-&gt;<span class="keyword">eval</span>(<span class="variable language_">$this</span>-&gt;delCommand, [<span class="variable language_">$this</span>-&gt;key, <span class="variable language_">$this</span>-&gt;id], <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="variable">$resp</span> == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * set expire</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> integer $expire</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setExpire</span>(<span class="params"><span class="keyword">int</span> <span class="variable">$expire</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="variable language_">$this</span>-&gt;seconds = <span class="variable">$expire</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="variable">$redis</span> = <span class="keyword">new</span> <span class="title class_">Redis</span>();</span><br><span class="line"><span class="variable">$redis</span>-&gt;<span class="title function_ invoke__">connect</span>(<span class="string">&#x27;192.168.4.61&#x27;</span>, <span class="number">6379</span>);</span><br><span class="line"><span class="variable">$key</span> = <span class="string">&#x27;lock:testtest&#x27;</span>;</span><br><span class="line"><span class="variable">$lock</span> = <span class="keyword">new</span> <span class="title class_">Lock</span>(<span class="variable">$redis</span>, <span class="variable">$key</span>);</span><br><span class="line"><span class="variable">$lock</span>-&gt;<span class="title function_ invoke__">setExpire</span>(<span class="number">60</span>);</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$lock</span>-&gt;<span class="title function_ invoke__">acquire</span>());</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$lock</span>-&gt;<span class="title function_ invoke__">acquire</span>());</span><br><span class="line"><span class="comment">// var_dump($lock-&gt;release());</span></span><br><span class="line"><span class="variable">$lock2</span> = <span class="keyword">new</span> <span class="title class_">Lock</span>(<span class="variable">$redis</span>, <span class="variable">$key</span>);</span><br><span class="line"><span class="variable">$lock2</span>-&gt;<span class="title function_ invoke__">setExpire</span>(<span class="number">30</span>);</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$lock2</span>-&gt;<span class="title function_ invoke__">acquire</span>());</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cache</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * redis</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@var</span> Redis </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="variable">$redis</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * wait next get</span></span><br><span class="line"><span class="comment"> * milliseconds</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@var</span> integer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="variable">$rate</span> = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * max loops</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@var</span> integer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="variable">$maxLoops</span> = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$redis</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="variable language_">$this</span>-&gt;redis = <span class="variable">$redis</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setRate</span>(<span class="params"><span class="keyword">int</span> <span class="variable">$rate</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="variable language_">$this</span>-&gt;rate = <span class="variable">$rate</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 第一版,初步实现</span></span><br><span class="line"><span class="comment"> * 通过闭包的方式实现</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> Closure $fn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> mixed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getCache</span>(<span class="params"><span class="variable">$key</span>, <span class="built_in">Closure</span> <span class="variable">$fn</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable language_">$this</span>-&gt;maxLoops; <span class="variable">$i</span> ++) &#123;</span><br><span class="line"><span class="comment">// get redis</span></span><br><span class="line"><span class="variable">$value</span> = <span class="variable language_">$this</span>-&gt;redis-&gt;<span class="title function_ invoke__">get</span>(<span class="variable">$key</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">empty</span>(<span class="variable">$value</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="variable">$value</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// global lock</span></span><br><span class="line"><span class="variable">$lock</span> = <span class="keyword">new</span> <span class="title class_">Lock</span>();</span><br><span class="line"><span class="keyword">if</span> (!<span class="variable">$lock</span>-&gt;<span class="title function_ invoke__">lock</span>()) &#123;</span><br><span class="line"><span class="comment">// wait next get</span></span><br><span class="line"><span class="title function_ invoke__">usleep</span>(<span class="variable">$this</span>-&gt;rate * <span class="number">1000</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$value</span> = <span class="variable">$fn</span>();</span><br><span class="line"><span class="comment">// 写入Redis</span></span><br><span class="line"><span class="variable language_">$this</span>-&gt;redis-&gt;<span class="title function_ invoke__">set</span>(<span class="variable">$key</span>, <span class="variable">$value</span>);</span><br><span class="line"><span class="comment">// global unlock</span></span><br><span class="line"><span class="variable">$lock</span>-&gt;<span class="title function_ invoke__">unlock</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="variable">$value</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DB Model</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;jerry&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getUserById</span>(<span class="params"><span class="variable">$userId</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="variable">$key</span> = <span class="string">&#x27;cache:user_id&#x27;</span> . <span class="variable">$userId</span>;</span><br><span class="line"><span class="variable">$redis</span> = <span class="keyword">new</span> <span class="title class_">Redis</span>();</span><br><span class="line"><span class="variable">$redis</span>-&gt;<span class="title function_ invoke__">connect</span>(<span class="string">&#x27;192.168.4.61&#x27;</span>, <span class="number">6379</span>);</span><br><span class="line"><span class="variable">$cache</span> = <span class="keyword">new</span> <span class="title class_">Cache</span>(<span class="variable">$redis</span>);</span><br><span class="line"><span class="variable">$cache</span>-&gt;<span class="title function_ invoke__">setRate</span>(<span class="number">300</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="variable">$cache</span>-&gt;<span class="title function_ invoke__">getCache</span>(<span class="variable">$key</span>, function () <span class="keyword">use</span> ($<span class="title">userId</span>) &#123;</span><br><span class="line">// <span class="title">DB</span></span><br><span class="line"><span class="title">return</span> (<span class="title">new</span> <span class="title">User</span>())-&gt;<span class="title">getName</span>();</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="variable">$user</span> = <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$user</span>-&gt;<span class="title function_ invoke__">getUserById</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h1 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h1><p>缓存雪崩：在某个时间段，缓存集体过期、redis宕机</p><h2 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h2><p>给key的失效时间设置为随机时间，避免集体过期；双缓存；加互斥锁</p><h2 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h2><ol><li>若是由于大量key过期所造成的，可以给key的ttl设置随机时间，避免集体过期</li><li>若是因为redis服务器宕机所导致的，可以搭建redis集群，保证高可用</li><li>可以从请求量层面进行解决，对缓存业务添加限流和服务降级策略</li><li>可以添加多级缓存，比如说nginx缓存</li></ol><h1 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h1><p>我们可以这样考虑，可以先判断key值是否存在，如果不存在，则不访问redis，那这样就可以拦截大量的请求，布隆过滤器恰好可以实现这样的需求。</p><p>布隆过滤器本质是一个二进制向量，初始化的时候每一个位置都是0，如下图，比如说a经过hash算法后得到一个下标位置，接下来就会把下标的值改为1，图中所示的是每一个元素经过三次hash运算，每一个红线代表一次hash算法，为什么要运算三次呢，这是为了减少hash冲突，当然hash算法不一定是三次，经过多次不同维度的哈市算法后，就把a值映射到了二进制向量里面，这样的好处很多，可以节省空间，假如说a值是一串很长的字符串，那么经过映射后就可以只占三位长度，并且查找速度很快。</p><p>如果布隆过滤器判断元素存在，则不一定存在，如果不存在，则一定不存在<br>如何理解这句话，因为有可能你一个元素运算得到的下标恰好是别的元素的下标，如果经过运算后布隆过滤器判断不存在，也就是说至少有一个下标是为0的，那肯定是不存在的</p><h2 id="布隆过滤器的使用"><a href="#布隆过滤器的使用" class="headerlink" title="布隆过滤器的使用"></a>布隆过滤器的使用</h2><p>注意的是布隆过滤器有一定的误判率，不可能达到100%的精准,首先初始化项目的时候从数据库查询出来所有的key值,然后放到布隆过滤器中。</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">Class Bloom</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* $var int $maps */</span></span><br><span class="line"><span class="keyword">private</span> <span class="variable">$maps</span> = <span class="number">14</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* $var int $bits */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="variable">$bits</span> = <span class="number">20000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* $var string $setScript */</span></span><br><span class="line"><span class="keyword">private</span> <span class="variable">$setScript</span> = <span class="string">&#x27;</span></span><br><span class="line"><span class="string">for _, offset in ipairs(ARGV) do</span></span><br><span class="line"><span class="string">redis.call(&quot;setbit&quot;, KEYS[1], offset, 1)</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">return true</span></span><br><span class="line"><span class="string">&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* $var string $testScript */</span></span><br><span class="line"><span class="keyword">private</span> <span class="variable">$testScript</span> = <span class="string">&#x27;</span></span><br><span class="line"><span class="string">for _, offset in ipairs(ARGV) do</span></span><br><span class="line"><span class="string">if tonumber(redis.call(&quot;getbit&quot;, KEYS[1], offset)) == 0 then</span></span><br><span class="line"><span class="string">return false</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">return true</span></span><br><span class="line"><span class="string">&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* $var string $key*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="variable">$key</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* $var mixed $redis*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="variable">$redis</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * construct</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mixed $redis</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$redis</span>, <span class="variable">$key</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="variable language_">$this</span>-&gt;redis = <span class="variable">$redis</span>;</span><br><span class="line"><span class="variable language_">$this</span>-&gt;key = <span class="variable">$key</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 格式化参数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array $offsets</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> array</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">buildOffsetArgs</span>(<span class="params"><span class="keyword">array</span> <span class="variable">$offsets</span></span>): <span class="title">array</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="title function_ invoke__">array_unshift</span>(<span class="variable">$offsets</span>, <span class="variable">$this</span>-&gt;key);</span><br><span class="line"><span class="keyword">return</span> <span class="variable">$offsets</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置过滤器的值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array $offsets</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">set</span>(<span class="params"><span class="keyword">array</span> <span class="variable">$offsets</span></span>): <span class="title">bool</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;redis-&gt;<span class="keyword">eval</span>(<span class="variable language_">$this</span>-&gt;setScript, <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">buildOffsetArgs</span>(<span class="variable">$offsets</span>), <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查值是否存在</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array $offsets</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params"><span class="keyword">array</span> <span class="variable">$offsets</span></span>): <span class="title">bool</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;redis-&gt;<span class="keyword">eval</span>(<span class="variable language_">$this</span>-&gt;testScript, <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">buildOffsetArgs</span>(<span class="variable">$offsets</span>), <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算bloom过滤器对应的bit位</span></span><br><span class="line"><span class="comment"> * 暂时使用crc32 获取摘要</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $data</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> array</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">getLocations</span>(<span class="params"><span class="keyword">string</span> <span class="variable">$data</span></span>): <span class="title">array</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="variable">$locations</span> = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable language_">$this</span>-&gt;maps; <span class="variable">$i</span> ++) &#123;</span><br><span class="line"><span class="variable">$data</span> .= (<span class="keyword">string</span>) <span class="variable">$i</span>;</span><br><span class="line"><span class="variable">$hashValue</span> = <span class="title function_ invoke__">crc32</span>(<span class="variable">$data</span>);</span><br><span class="line"><span class="variable">$locations</span>[<span class="variable">$i</span>] = <span class="variable">$hashValue</span> % <span class="variable language_">$this</span>-&gt;bits;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="variable">$locations</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 增加过滤器数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $data</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"><span class="keyword">string</span> <span class="variable">$data</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="variable">$locations</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">getLocations</span>(<span class="variable">$data</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">set</span>(<span class="variable">$locations</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断值是否存在</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $data</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">exists</span>(<span class="params"><span class="keyword">string</span> <span class="variable">$data</span></span>): <span class="title">bool</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="variable">$locations</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">getLocations</span>(<span class="variable">$data</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">check</span>(<span class="variable">$locations</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置时间 </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> int $second</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">expire</span>(<span class="params"><span class="keyword">int</span> <span class="variable">$second</span></span>): <span class="title">bool</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;redis-&gt;<span class="title function_ invoke__">expire</span>(<span class="variable">$this</span>-&gt;key, <span class="variable">$second</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="variable">$redis</span> = <span class="keyword">new</span> <span class="title class_">Redis</span>();</span><br><span class="line"><span class="variable">$redis</span>-&gt;<span class="title function_ invoke__">connect</span>(<span class="string">&#x27;192.168.4.61&#x27;</span>, <span class="number">6379</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$bloomKey</span> = <span class="string">&#x27;bloom:test&#x27;</span>;</span><br><span class="line"><span class="variable">$data</span> = <span class="string">&#x27;helloworld2&#x27;</span>;</span><br><span class="line"><span class="variable">$bloom</span> = <span class="keyword">new</span> <span class="title class_">Bloom</span>(<span class="variable">$redis</span>, <span class="variable">$bloomKey</span>);</span><br><span class="line"><span class="comment">// var_dump($bloom-&gt;add($data));</span></span><br><span class="line"><span class="comment">// var_dump($bloom-&gt;expire(600));</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$bloom</span>-&gt;<span class="title function_ invoke__">exists</span>(<span class="variable">$data</span>));</span><br></pre></td></tr></table></figure><h2 id="加了布隆过滤器的过程如下"><a href="#加了布隆过滤器的过程如下" class="headerlink" title="加了布隆过滤器的过程如下"></a>加了布隆过滤器的过程如下</h2><ol><li>当应用访问的时候，先去布隆过滤器中判断kedy值，如果发觉没有key值不存在，直接返回</li><li>如果key值在布隆过滤器存在，则去访问redis，由于是有误判率的，所以redis也有可能不存在</li><li>那么这时候就去访问数据库，数据库不存在，那就直接返回空就行</li></ol><p>如果误判率为3%，当有100万个请求同时过来的时候，布隆过滤器已经挡住了97万个请求，剩下3万个请求假如是误判的，这时候再访问数据库可以通过加锁的方式实现，只有竞争到锁了就去访问数据库，这样就完全可以解决缓存穿透问题</p><h2 id="布隆过滤器的应用"><a href="#布隆过滤器的应用" class="headerlink" title="布隆过滤器的应用"></a>布隆过滤器的应用</h2><p>比如说输入用户名的时候，可以马上检测出该用户名是否存在，黑名单机制，单词错误检测等</p>]]></content>
      
      
      <categories>
          
          <category> 计算机技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> Cache </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用限流方案</title>
      <link href="/rainbow-bubbles/Technology/%E5%B8%B8%E7%94%A8%E9%99%90%E6%B5%81%E6%96%B9%E6%A1%88/"/>
      <url>/rainbow-bubbles/Technology/%E5%B8%B8%E7%94%A8%E9%99%90%E6%B5%81%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="六种限流实现方案"><a href="#六种限流实现方案" class="headerlink" title="六种限流实现方案"></a>六种限流实现方案</h1><h2 id="为什么要限流"><a href="#为什么要限流" class="headerlink" title="为什么要限流"></a>为什么要限流</h2><p>车辆限行就是一种生活中很常见的限流策略，他除了给我带来了以上的好处之外，还给我们美好的生活环境带来了一丝改善，并且快速增长的私家车已经给我们的交通带来了巨大的“负担”，如果再不限行，可能所有的车都要被堵在路上，这就是限流给我们的生活带来的巨大好处。</p><p>从生活回到程序中，假设一个系统只能为 10W 人提供服务，突然有一天因为某个热点事件，造成了系统短时间内的访问量迅速增加到了 50W，那么导致的直接结果是系统崩溃，任何人都不能用系统了，显然只有少人数能用远比所有人都不能用更符合我们的预期，因此这个时候我们要使用「限流」了。</p><h2 id="限流分类"><a href="#限流分类" class="headerlink" title="限流分类"></a>限流分类</h2><p>限流的分类:</p><ol><li>合法性验证限流：比如验证码、IP 黑名单等，这些手段可以有效的防止恶意攻击和爬虫采集；</li><li>容器限流：比如 Tomcat、Nginx 等限流手段，其中 Tomcat 可以设置最大线程数（maxThreads），当并发超过最大线程数会排队等待执行；而 Nginx 提供了两种限流手段：一是控制速率，二是控制并发连接数；</li><li>服务端限流：比如我们在服务器端通过限流算法实现限流，此项也是我们本文介绍的重点。</li></ol><p>合法性验证限流为最常规的业务代码，就是普通的验证码和 IP 黑名单系统，本文就不做过多的叙述了，我们重点来看下后两种限流的实现方案：容器限流和服务端限流。</p><h2 id="容器限流"><a href="#容器限流" class="headerlink" title="容器限流"></a>容器限流</h2><h3 id="Tomcat-限流"><a href="#Tomcat-限流" class="headerlink" title="Tomcat 限流"></a>Tomcat 限流</h3><p>Tomcat 8.5 版本的最大线程数在 conf&#x2F;server.xml 配置中，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">maxThreads</span>=<span class="string">&quot;150&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>其中 <code>maxThreads</code> 就是 Tomcat 的最大线程数，当请求的并发大于此值（maxThreads）时，请求就会排队执行，这样就完成了限流的目的。</p><blockquote><p>小贴士：maxThreads 的值可以适当的调大一些，此值默认为 150（Tomcat 版本 8.5.42），但这个值也不是越大越好，要看具体的硬件配置，需要注意的是每开启一个线程需要耗用 1MB 的 JVM 内存空间用于作为线程栈之用，并且线程越多 GC 的负担也越重。最后需要注意一下，操作系统对于进程中的线程数有一定的限制，Windows 每个进程中的线程数不允许超过 2000，Linux 每个进程中的线程数不允许超过 1000。</p></blockquote><h3 id="Nginx-限流"><a href="#Nginx-限流" class="headerlink" title="Nginx 限流"></a>Nginx 限流</h3><p>Nginx 提供了两种限流手段：一是控制速率，二是控制并发连接数。</p><h4 id="控制速率"><a href="#控制速率" class="headerlink" title="控制速率"></a>控制速率</h4><p>我们需要使用 <code>limit_req_zone</code> 用来限制单位时间内的请求数，即速率限制，示例配置如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">limit_req_zone $binary_remote_addr zone=mylimit:<span class="number">10</span>m rate=<span class="number">2</span>r/s;</span><br><span class="line">server &#123; </span><br><span class="line">    location / &#123; </span><br><span class="line">        limit_req zone=mylimit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上配置表示，限制每个 IP 访问的速度为 2r&#x2F;s，因为 Nginx 的限流统计是基于毫秒的，我们设置的速度是 2r&#x2F;s，转换一下就是 500ms 内单个 IP 只允许通过 1 个请求，从 501ms 开始才允许通过第 2 个请求。</p><h4 id="速率限制升级版"><a href="#速率限制升级版" class="headerlink" title="速率限制升级版"></a>速率限制升级版</h4><p>上面的速率控制虽然很精准但是应用于真实环境未免太苛刻了，真实情况下我们应该控制一个 IP 单位总时间内的总访问次数，而不是像上面那么精确但毫秒，我们可以使用 burst 关键字开启此设置，示例配置如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">limit_req_zone $binary_remote_addr zone=mylimit:<span class="number">10</span>m rate=<span class="number">2</span>r/s;</span><br><span class="line">server &#123; </span><br><span class="line">    location / &#123; </span><br><span class="line">        limit_req zone=mylimit burst=<span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>burst&#x3D;4 表示每个 IP 最多允许4个突发请求，如果单个 IP 在 10ms 内发送 6 次请求。</p><h4 id="控制并发数"><a href="#控制并发数" class="headerlink" title="控制并发数"></a>控制并发数</h4><p>利用 <code>limit_conn_zone</code> 和 <code>limit_conn</code> 两个指令即可控制并发数，示例配置如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">limit_conn_zone $binary_remote_addr zone=perip:<span class="number">10</span>m;</span><br><span class="line">limit_conn_zone $server_name zone=perserver:<span class="number">10</span>m;</span><br><span class="line">server &#123;</span><br><span class="line">    ...</span><br><span class="line">    limit_conn perip <span class="number">10</span>;</span><br><span class="line">    limit_conn perserver <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 limit_conn perip 10 表示限制单个 IP 同时最多能持有 10 个连接；limit_conn perserver 100 表示 server 同时能处理并发连接的总数为 100 个。</p><blockquote><p>小贴士：只有当 request header 被后端处理后，这个连接才进行计数。</p></blockquote><h2 id="服务端限流"><a href="#服务端限流" class="headerlink" title="服务端限流"></a>服务端限流</h2><p>服务端限流需要配合限流的算法来执行，而算法相当于执行限流的“大脑”，用于指导限制方案的实现。</p><p>限流的常见算法有以下三种：</p><ol><li>时间窗口算法</li><li>漏桶算法</li><li>令牌算法</li></ol><h3 id="1-时间窗口算法"><a href="#1-时间窗口算法" class="headerlink" title="1. 时间窗口算法"></a>1. 时间窗口算法</h3><p>所谓的滑动时间算法指的是以当前时间为截止时间，往前取一定的时间，比如往前取 60s 的时间，在这 60s 之内运行最大的访问数为 100，此时算法的执行逻辑为，先清除 60s 之前的所有请求记录，再计算当前集合内请求数量是否大于设定的最大请求数 100，如果大于则执行限流拒绝策略，否则插入本次请求记录并返回可以正常执行的标识给客户端。</p><p>滑动时间窗口如下图所示：<br><img src="https://r2.721503.xyz/blog/1747315479576.png"></p><p>其中每一小个表示 10s，被红色虚线包围的时间段则为需要判断的时间间隔，比如 60s 秒允许 100 次请求，那么红色虚线部分则为 60s。</p><p>可以借助 Redis 的有序集合 ZSet 来实现时间窗口算法限流，实现的过程是先使用 ZSet 的 key 存储限流的 ID，score 用来存储请求的时间，每次有请求访问来了之后，先清空之前时间窗口的访问量，统计现在时间窗口的个数和最大允许访问量对比，如果大于等于最大访问量则返回 false 执行限流操作，负责允许执行业务逻辑，并且在 ZSet 中添加一条有效的访问记录，具体实现代码如下。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Notes</span>:滑动窗口算法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>:如果,</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2022/9/16,</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 20:20,</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">SlideTimeWindow</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2.redis 滑动窗口实现方式</span></span><br><span class="line"><span class="comment">     * 限制1分钟内最大只能请求10次</span></span><br><span class="line"><span class="comment">     * 使用redis事务保证redis原子性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="variable">$redis</span> = <span class="variable language_">$this</span>-&gt;redis;</span><br><span class="line">    <span class="variable">$limitTime</span> = <span class="number">60</span>;</span><br><span class="line">    <span class="variable">$maxCount</span> = <span class="number">10</span>;</span><br><span class="line">    <span class="variable">$redisKey</span> = <span class="string">&quot;slide_api&quot;</span>;</span><br><span class="line">    <span class="variable">$nowTime</span> = <span class="title function_ invoke__">time</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用管道提升性能 pipe</span></span><br><span class="line">    <span class="variable">$pipe</span> = <span class="variable">$redis</span>-&gt;<span class="title function_ invoke__">multi</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//value 和 score 都使用时间戳,因为相同的元素会覆盖</span></span><br><span class="line">    <span class="variable">$pipe</span>-&gt;<span class="title function_ invoke__">zAdd</span>(<span class="variable">$redisKey</span>, <span class="variable">$nowTime</span>, <span class="variable">$nowTime</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移除时间窗口之前的行为记录，剩下的都是时间窗口内的</span></span><br><span class="line">    <span class="variable">$pipe</span>-&gt;<span class="title function_ invoke__">zRemRangeByScore</span>(<span class="variable">$redisKey</span>, <span class="number">0</span>, <span class="variable">$nowTime</span> - <span class="variable">$limitTime</span>);</span><br><span class="line">    <span class="comment">//查看redis里还有多少次</span></span><br><span class="line">    <span class="variable">$pipe</span>-&gt;<span class="title function_ invoke__">zCard</span>(<span class="variable">$redisKey</span>);</span><br><span class="line"></span><br><span class="line">    <span class="variable">$pipe</span>-&gt;<span class="title function_ invoke__">expire</span>(<span class="variable">$redisKey</span>, <span class="number">60</span> + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="variable">$replies</span> = <span class="variable">$pipe</span>-&gt;<span class="title function_ invoke__">exec</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有限时间窗口内的数量超过限制返回 true:false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$replies</span>[<span class="number">2</span>] &lt;= <span class="variable">$maxCount</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此实现方式存在的缺点有两个：</p><ol><li>使用 ZSet 存储有每次的访问记录，如果数据量比较大时会占用大量的空间，比如 60s 允许 100W 访问时；</li><li>此代码的执行非原子操作，先判断后增加，中间空隙可穿插其他业务逻辑的执行，最终导致结果不准确。</li></ol><h3 id="2-漏桶算法"><a href="#2-漏桶算法" class="headerlink" title="2. 漏桶算法"></a>2. 漏桶算法</h3><p>漏桶算法的灵感源于漏斗，如下图所示：<br><img src="https://r2.721503.xyz/blog/1747315858624.png"></p><p>滑动时间算法有一个问题就是在一定范围内，比如 60s 内只能有 10 个请求，当第一秒时就到达了 10 个请求，那么剩下的 59s 只能把所有的请求都给拒绝掉，而漏桶算法可以解决这个问题。</p><p>漏桶算法类似于生活中的漏斗，无论上面的水流倒入漏斗有多大，也就是无论请求有多少，它都是以均匀的速度慢慢流出的。当上面的水流速度大于下面的流出速度时，漏斗会慢慢变满，当漏斗满了之后就会丢弃新来的请求;当上面的水流速度小于下面流出的速度的话，漏斗永远不会被装满，并且可以一直流出。</p><p>上面我们演示 Nginx 的控制速率其实使用的就是漏桶算法，当然我们也可以借助 Redis 很方便的实现漏桶算法。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="variable">$_water</span>;    <span class="comment">//漏斗的当前水量(也就是请求数)</span></span><br><span class="line"><span class="keyword">private</span> <span class="variable">$_burst</span> = <span class="number">10</span>;   <span class="comment">//漏斗总量(超过将直接舍弃)</span></span><br><span class="line"><span class="keyword">private</span> <span class="variable">$_rate</span> = <span class="number">1</span>; <span class="comment">//漏斗出水速率(限流速度)</span></span><br><span class="line"><span class="keyword">private</span> <span class="variable">$_lastTime</span>; <span class="comment">//记录每次请求的时间(因为需要记录每次请求之间的出水量也就是请求数)</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">leakBucket</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable">$nowTime</span> = <span class="title function_ invoke__">time</span>();</span><br><span class="line">    <span class="variable">$redisKey</span> = <span class="string">&quot;leakBucket_api&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">empty</span>(<span class="variable">$time</span> = <span class="variable language_">$this</span>-&gt;redis-&gt;<span class="title function_ invoke__">get</span>(<span class="variable">$redisKey</span>))) &#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;_lastTime = <span class="variable">$time</span>; <span class="comment">//获取上一次访问时间</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">empty</span>(<span class="variable">$water</span> = <span class="variable language_">$this</span>-&gt;redis-&gt;<span class="title function_ invoke__">get</span>(<span class="string">&#x27;water&#x27;</span>))) &#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;_water = <span class="variable">$water</span>;<span class="comment">//获取当前剩余量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable">$s</span> = <span class="variable">$nowTime</span> - <span class="variable language_">$this</span>-&gt;_lastTime; <span class="comment">//请求间隔</span></span><br><span class="line"></span><br><span class="line">    <span class="variable">$outCount</span> = <span class="variable">$s</span> * <span class="variable language_">$this</span>-&gt;_rate;<span class="comment">//请求间隔 * 出水速度 （着段时间应该出多少滴水）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//桶里的水去 -  这段时间要出的水 = 桶里剩余的水</span></span><br><span class="line">    <span class="variable language_">$this</span>-&gt;_water = (<span class="variable language_">$this</span>-&gt;_water - <span class="variable">$outCount</span>);</span><br><span class="line">    <span class="comment">//桶里剩余的水为 -数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">$this</span>-&gt;_water &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;_water = <span class="number">0</span>; <span class="comment">//漏斗重新赋值为空</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">$this</span>-&gt;_water &gt; <span class="variable language_">$this</span>-&gt;_burst) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;超出桶限制&quot;</span> . PHP_EOL;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">print_r</span>(<span class="variable">$this</span>-&gt;_water);</span><br><span class="line">    <span class="comment">//重新赋值时间  下次请求这个时间 就为上次时间</span></span><br><span class="line">    <span class="variable language_">$this</span>-&gt;redis-&gt;<span class="title function_ invoke__">set</span>(<span class="variable">$redisKey</span>, <span class="variable">$nowTime</span>);</span><br><span class="line">    <span class="comment">//把桶里剩余的水 重新赋值到redis里 并+1 本次也算请求</span></span><br><span class="line">    <span class="variable language_">$this</span>-&gt;redis-&gt;<span class="title function_ invoke__">set</span>(<span class="string">&#x27;water&#x27;</span>, <span class="variable">$this</span>-&gt;_water + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-令牌算法"><a href="#3-令牌算法" class="headerlink" title="3. 令牌算法"></a>3. 令牌算法</h3><p>在令牌桶算法中有一个程序以某种恒定的速度生成令牌，并存入令牌桶中，而每个请求需要先获取令牌才能执行，如果没有获取到令牌的请求可以选择等待或者放弃执行，如下图所示：</p><p><img src="https://r2.721503.xyz/blog/1747316232604.png"><br>具体实现代码如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TokenLimit</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="variable">$script</span> = <span class="string">&#x27;</span></span><br><span class="line"><span class="string">-- 生成token的速率 </span></span><br><span class="line"><span class="string">local rate = tonumber(ARGV[1])</span></span><br><span class="line"><span class="string">-- 令牌桶最大容量</span></span><br><span class="line"><span class="string">local capacity = tonumber(ARGV[2])</span></span><br><span class="line"><span class="string">-- 当前时间</span></span><br><span class="line"><span class="string">local now = tonumber(ARGV[3])</span></span><br><span class="line"><span class="string">-- 获取token的数量</span></span><br><span class="line"><span class="string">local requested = tonumber(ARGV[4])</span></span><br><span class="line"><span class="string">-- 填满整个桶需要多久时间</span></span><br><span class="line"><span class="string">local fill_time = capacity / rate</span></span><br><span class="line"><span class="string">-- 时间取整</span></span><br><span class="line"><span class="string">local ttl = math.floor(fill_time*2)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">-- 获取目前桶中剩余令牌的数量</span></span><br><span class="line"><span class="string">-- 如果第一次进入，则设置桶内令牌的数量为最大值</span></span><br><span class="line"><span class="string">local last_tokens = tonumber(redis.call(&quot;get&quot;, KEYS[1]))</span></span><br><span class="line"><span class="string">if last_tokens == nil then</span></span><br><span class="line"><span class="string">    last_tokens = capacity</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">-- 上次更新 桶的时间</span></span><br><span class="line"><span class="string">local last_refreshed = tonumber(redis.call(&quot;get&quot;, KEYS[2]))</span></span><br><span class="line"><span class="string">if last_refreshed == nil then</span></span><br><span class="line"><span class="string">    last_refreshed = 0</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">-- 上次从桶中获取令牌的时间距离现在的时间 </span></span><br><span class="line"><span class="string">local delta = math.max(0, now - last_refreshed)</span></span><br><span class="line"><span class="string">-- 上次从桶中获取令牌的时间距离现在的时间内总共生成了令牌的数量</span></span><br><span class="line"><span class="string">-- 如果超过了最大数量则丢弃多余的令牌</span></span><br><span class="line"><span class="string">local filled_tokens = math.min(capacity, last_tokens + (rate * delta))</span></span><br><span class="line"><span class="string">-- 本次请求令牌数量是否足够</span></span><br><span class="line"><span class="string">local allowed = filled_tokens &gt;= requested</span></span><br><span class="line"><span class="string">-- 令牌桶剩余数量</span></span><br><span class="line"><span class="string">local new_tokens = filled_tokens</span></span><br><span class="line"><span class="string">if allowed then</span></span><br><span class="line"><span class="string">    new_tokens = filled_tokens - requested</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">-- 更新桶中剩余令牌的数量</span></span><br><span class="line"><span class="string">redis.call(&quot;setex&quot;, KEYS[1], ttl, new_tokens)</span></span><br><span class="line"><span class="string">-- 更新获取令牌的时间</span></span><br><span class="line"><span class="string">redis.call(&quot;setex&quot;, KEYS[2], ttl, now)</span></span><br><span class="line"><span class="string">return allowed</span></span><br><span class="line"><span class="string">&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> string $key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$key</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> string $timestampKey</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$timestampKey</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> int $rate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$rate</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> int $capacity</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$capacity</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> Redis $redis</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$redis</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> string $tokenFormat</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$tokenFormat</span> = <span class="string">&#x27;%s.token&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> string $timestampFormat</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$timestampFormat</span> = <span class="string">&#x27;%s.ts&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * TokenLimit constructor.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> string $key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> int $rate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> int $burst</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Redis $redis</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="keyword">string</span> <span class="variable">$key</span>, <span class="keyword">int</span> <span class="variable">$rate</span>, <span class="keyword">int</span> <span class="variable">$burst</span>, Redis <span class="variable">$redis</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;key = <span class="title function_ invoke__">sprintf</span>(<span class="variable">$this</span>-&gt;tokenFormat, <span class="variable">$key</span>);</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;timestampKey = <span class="title function_ invoke__">sprintf</span>(<span class="variable">$this</span>-&gt;timestampFormat, <span class="variable">$key</span>);</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;rate = <span class="variable">$rate</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;capacity = <span class="variable">$burst</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;redis = <span class="variable">$redis</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * build argv</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> int $now_time</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> int $n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">buildArgv</span>(<span class="params"><span class="keyword">int</span> <span class="variable">$now_time</span>, <span class="keyword">int</span> <span class="variable">$n</span></span>): <span class="title">array</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">array</span>(<span class="variable language_">$this</span>-&gt;key, <span class="variable language_">$this</span>-&gt;timestampKey, <span class="variable language_">$this</span>-&gt;rate, <span class="variable language_">$this</span>-&gt;capacity, <span class="variable">$now_time</span>, <span class="variable">$n</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * execute script</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> int $now_time</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> int $n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">reserve</span>(<span class="params"><span class="keyword">int</span> <span class="variable">$now_time</span>, <span class="keyword">int</span> <span class="variable">$n</span></span>): <span class="title">bool</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;redis-&gt;<span class="keyword">eval</span>(<span class="variable language_">$this</span>-&gt;script, <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">buildArgv</span>(<span class="variable">$now_time</span>, <span class="variable">$n</span>), <span class="number">2</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * reserve multi token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> int $n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">allowN</span>(<span class="params"><span class="keyword">int</span> <span class="variable">$n</span></span>): <span class="title">bool</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$now_time</span> = <span class="title function_ invoke__">time</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">reserve</span>(<span class="variable">$now_time</span>, <span class="variable">$n</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * reserve one token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">allow</span>(<span class="params"></span>): <span class="title">bool</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">allowN</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$redis</span> = <span class="keyword">new</span> <span class="title class_">Redis</span>();</span><br><span class="line"><span class="variable">$redis</span>-&gt;<span class="title function_ invoke__">connect</span>(<span class="string">&quot;192.168.4.61&quot;</span>, <span class="number">6379</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$tokenKey</span> = <span class="string">&#x27;token:test&#x27;</span>;</span><br><span class="line"><span class="variable">$tokenLimit</span> = <span class="keyword">new</span> <span class="title class_">TokenLimit</span>(<span class="variable">$tokenKey</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="variable">$redis</span>);</span><br><span class="line"><span class="variable">$allowed</span> = <span class="variable">$tokenLimit</span>-&gt;<span class="title function_ invoke__">allow</span>();</span><br><span class="line"><span class="variable">$allowed</span> = <span class="variable">$tokenLimit</span>-&gt;<span class="title function_ invoke__">allow</span>();</span><br><span class="line"><span class="variable">$allowed</span> = <span class="variable">$tokenLimit</span>-&gt;<span class="title function_ invoke__">allow</span>();</span><br><span class="line"><span class="variable">$allowed</span> = <span class="variable">$tokenLimit</span>-&gt;<span class="title function_ invoke__">allow</span>();</span><br><span class="line"><span class="variable">$allowed</span> = <span class="variable">$tokenLimit</span>-&gt;<span class="title function_ invoke__">allow</span>();</span><br><span class="line"><span class="variable">$allowed</span> = <span class="variable">$tokenLimit</span>-&gt;<span class="title function_ invoke__">allow</span>();</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$allowed</span>);</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文提供了 6 种具体的实现限流的手段，他们分别是：<code>Tomcat</code> 使用 <code>maxThreads</code> 来实现限流；<code>Nginx</code> 提供了两种限流方式，一是通过 <code>limit_req_zone</code> 和 <code>burst</code> 来实现速率限流，二是通过 <code>limit_conn_zone</code> 和 <code>limit_conn</code> 两个指令控制并发连接的总数。最后我们讲了时间窗口算法借助 <code>Redis</code> 的有序集合可以实现，还有漏桶算法。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 流量限流 </tag>
            
            <tag> 高并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang面试常见问题总结</title>
      <link href="/rainbow-bubbles/Technology/golang%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/rainbow-bubbles/Technology/golang%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言特点"><a href="#Go语言特点" class="headerlink" title="Go语言特点"></a>Go语言特点</h1><p>Go语言相比C++&#x2F;Java等语言是优雅且简洁的，它既保留了C++的高性能，又可以像Java，Python优雅的调用三方库和管理项目，同时还有接口，自动垃圾回收和goroutine等让人拍案叫绝的设计。<br>有许多基于Go的优秀项目。Docker，Kubernetes，etcd，deis，flynn，lime，revel等等。Go无疑是云时代的最好语言！<br>题外话到此为止，在面试中，我们需要深入了解Go语言特性，并适当辅以源码阅读（Go源码非常人性化，注释非常详细，基本上只要你学过Go就能看懂）来提升能力。常考的点包括：切片，通道，异常处理，Goroutine，GMP模型，字符串高效拼接，指针，反射，接口，sync，go test和相关工具链。）</p><h1 id="切片与数组的区别"><a href="#切片与数组的区别" class="headerlink" title="切片与数组的区别"></a>切片与数组的区别</h1><p>在Go语言中，数组（Array）和切片（Slice）是两种不同的数据类型，它们有以下区别： </p><ol><li>长度固定 vs 动态长度：</li></ol><ul><li>数组是长度固定的，在声明时需要指定长度，并且无法改变长度。</li><li>切片是动态长度的，可以根据需要自动调整长度，无需在声明时指定长度。</li></ul><ol start="2"><li>值类型 vs 引用类型：</li></ol><ul><li>数组是值类型，赋值或传递数组时会进行值的复制。</li><li>切片是引用类型，赋值或传递切片时会共享底层数据，修改其中一个切片会影响其他引用该底层数组的切片。</li></ul><ol start="3"><li>内存分配：</li></ol><ul><li>数组在声明时会直接分配连续的内存空间，长度固定。</li><li>切片是基于数组的动态长度的视图，底层使用数组来存储数据，但可以根据需要动态调整切片的长度。</li></ul><ol start="4"><li>灵活性：</li></ol><ul><li>数组的长度固定，无法动态增加或缩小，需要重新创建一个新的数组。</li><li>切片可以通过追加元素或切割操作来动态增加或缩小长度。</li></ul><ol start="5"><li>使用场景：</li></ol><ul><li>数组适用于固定长度的数据集合，如存储一组固定大小的元素。</li><li>切片适用于动态长度的数据集合，如存储可变数量的元素，并且经常需要进行动态调整。</li></ul><p>总的来说，数组适用于长度固定的数据集合，而切片适用于动态长度的数据集合。切片提供了更大的灵活性和方便的操作，是在Go语言中更常用的数据结构。</p><h1 id="切片使用方法"><a href="#切片使用方法" class="headerlink" title="切片使用方法"></a>切片使用方法</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><ol><li>make 函数初始化</li></ol><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><ol start="2"><li>从数组中截取</li></ol><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr := [<span class="number">4</span>]<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s := arr[<span class="number">2</span>:<span class="number">3</span>]</span><br></pre></td></tr></table></figure><h2 id="获取长度和容量"><a href="#获取长度和容量" class="headerlink" title="获取长度和容量"></a>获取长度和容量</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">len</span>(s)</span><br><span class="line"><span class="built_in">cap</span>(s)</span><br></pre></td></tr></table></figure><h2 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr := [<span class="number">4</span>]<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s := arr[<span class="number">2</span>:<span class="number">3</span>]</span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">append</span>(s[:<span class="number">2</span>], s[<span class="number">3</span>:]...)</span><br></pre></td></tr></table></figure><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d:%d\n&quot;</span>, k, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="切片的扩容机制"><a href="#切片的扩容机制" class="headerlink" title="切片的扩容机制"></a>切片的扩容机制</h1><h2 id="Go1-18版前"><a href="#Go1-18版前" class="headerlink" title="Go1.18版前"></a>Go1.18版前</h2><p>新申请的容量如果大于当前容量的两倍，会将新申请的容量直接作为新的容量，如果新申请的容量小于当前容量的两倍，会有一个阈值，即当前切片容量小于1024时，切片会将当前容量的2倍作为新申请的容量，如果大于等于1024，会将当前的容量的1.25倍作为新申请的容量。</p><h3 id="源码片段"><a href="#源码片段" class="headerlink" title="源码片段"></a>源码片段</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">newcap := old.<span class="built_in">cap</span></span><br><span class="line">doublecap := newcap + newcap</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">cap</span> &gt; doublecap &#123;</span><br><span class="line">newcap = <span class="built_in">cap</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> old.<span class="built_in">cap</span> &lt; <span class="number">1024</span> &#123;</span><br><span class="line">newcap = doublecap</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Check 0 &lt; newcap to detect overflow</span></span><br><span class="line"><span class="comment">// and prevent an infinite loop.</span></span><br><span class="line"><span class="keyword">for</span> <span class="number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="built_in">cap</span> &#123;</span><br><span class="line">newcap += newcap / <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Set newcap to the requested cap when</span></span><br><span class="line"><span class="comment">// the newcap calculation overflowed.</span></span><br><span class="line"><span class="keyword">if</span> newcap &lt;= <span class="number">0</span> &#123;</span><br><span class="line">newcap = <span class="built_in">cap</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Go-1-18版本后"><a href="#Go-1-18版本后" class="headerlink" title="Go 1.18版本后"></a>Go 1.18版本后</h2><p>新申请的容量如果大于当前容量的两倍，会将新申请的容量直接作为新的容量，如果新申请的容量小于当前容量的两倍，会有一个阈值，即当前切片容量小于256时，切片会将当前容量的2倍作为新申请的容量，如果大于等于256，会将当前的容量的1.25倍+192作为新申请的容量，扩容的时候更加平滑，不会出现从2到1.25的突变。</p><h3 id="源码片段-1"><a href="#源码片段-1" class="headerlink" title="源码片段"></a>源码片段</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">newcap := old.<span class="built_in">cap</span></span><br><span class="line">doublecap := newcap + newcap</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">cap</span> &gt; doublecap &#123;</span><br><span class="line">newcap = <span class="built_in">cap</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">const</span> threshold = <span class="number">256</span></span><br><span class="line"><span class="keyword">if</span> old.<span class="built_in">cap</span> &lt; threshold &#123;</span><br><span class="line">newcap = doublecap</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Check 0 &lt; newcap to detect overflow</span></span><br><span class="line"><span class="comment">// and prevent an infinite loop.</span></span><br><span class="line"><span class="keyword">for</span> <span class="number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="built_in">cap</span> &#123;</span><br><span class="line"><span class="comment">// Transition from growing 2x for small slices</span></span><br><span class="line"><span class="comment">// to growing 1.25x for large slices. This formula</span></span><br><span class="line"><span class="comment">// gives a smooth-ish transition between the two.</span></span><br><span class="line">newcap += (newcap + <span class="number">3</span>*threshold) / <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Set newcap to the requested cap when</span></span><br><span class="line"><span class="comment">// the newcap calculation overflowed.</span></span><br><span class="line"><span class="keyword">if</span> newcap &lt;= <span class="number">0</span> &#123;</span><br><span class="line">newcap = <span class="built_in">cap</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h1><h2 id="互斥锁-Mutex"><a href="#互斥锁-Mutex" class="headerlink" title="互斥锁 (Mutex)"></a>互斥锁 (Mutex)</h2><p>Mutex是Golang的互斥锁，作用是在并发程序中对共享资源的保护，避免出现数据竞争问题。<br>使用方法：Mutex实现了Locker接口</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Locker <span class="keyword">interface</span> &#123;</span><br><span class="line">    Lock()</span><br><span class="line">    Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是互斥锁 Mutex 提供两个方法 Lock 和 Unlock</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(m *Mutex)</span></span>Lock()</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(m *Mutex)</span></span>Unlock()</span><br></pre></td></tr></table></figure><p>使用实例</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line">    <span class="keyword">import</span> (</span><br><span class="line">        <span class="string">&quot;fmt&quot;</span></span><br><span class="line">        <span class="string">&quot;sync&quot;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 互斥锁保护计数器</span></span><br><span class="line">        <span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">        <span class="comment">// 计数器的值</span></span><br><span class="line">        <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">        wg.Add(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动10个gourontine</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">            <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                <span class="keyword">defer</span> wg.Done()</span><br><span class="line">                <span class="comment">// 累加10万次</span></span><br><span class="line">                <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">100000</span>; j++ &#123;</span><br><span class="line">                    mu.Lock()</span><br><span class="line">                    count++</span><br><span class="line">                    mu.Unlock()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;()</span><br><span class="line">        &#125;</span><br><span class="line">        wg.Wait()</span><br><span class="line">        fmt.Println(count)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Mutex的两种模式"><a href="#Mutex的两种模式" class="headerlink" title="Mutex的两种模式"></a>Mutex的两种模式</h3><p>Mutex 可能处于两种操作模式下：</p><ol><li>正常模式<br>在正常模式下，所有的goroutine会按照先进先出的顺序进行等待，被唤醒的goroutine不会直接持有锁，会和新进来的锁进行竞争，新请求进来的锁会更容易抢占到锁，因为正在CPU上运行，因此刚唤醒的goroutine可能会竞争失败，回到队列头部；如果队列的goroutine超过1毫秒的等待时间，则会转换到饥饿模式。</li><li>饥饿模式<br>在饥饿模式下，锁会直接交给队列的第一个goroutine，新进来的goroutine不会抢占锁也不会进入自旋状态，直接进入队列尾部；如果当前goroutine已经是队列的最后一个或者当前goroutine等待时间小于1毫秒，则会转换到正常模式</li></ol><p>正常模式下，性能更好，但饥饿模式解决取锁公平问题，性能较差。<br>3. 底层结构</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">     state <span class="type">int32</span></span><br><span class="line">     sema  <span class="type">uint32</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">const</span> (</span><br><span class="line">     mutexLocked = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span> <span class="comment">// mutex is locked</span></span><br><span class="line">     mutexWoken</span><br><span class="line">     mutexWaiterShift = <span class="literal">iota</span></span><br><span class="line"> )</span><br></pre></td></tr></table></figure><p>state 是一个复合型的字段，一个字段包含多个意义:</p><p>mutexWaiters 阻塞等待的waiter数量</p><p>mutexStarving 饥饿标记</p><p>mutexWoken 唤醒标记</p><p>mutexLocked 持有锁的标记</p><ol start="4"><li>易错场景</li></ol><ul><li>Lock&#x2F;Unlock没有成对出现（加锁后必须有解锁操作），如果Lock之后，没有Unlock会出现死锁的情况，或者是因为 Unlock 一个未Lock的 Mutex 而导致 panic</li><li>复制已经使用过的Mutex，因为复制了已经使用了的Mutex，导致锁无法使用，程序处于死锁的状态</li><li>重入锁，Mutex是不可重入锁，如果一个线程成功获取到这个锁。之后，如果其它线程再请求这个锁，就会处于阻塞等待的状态</li><li>死锁，两个或两个以上的goroutine争夺共享资源，互相等待对方的锁释放</li></ul><h2 id="读写锁（RWMutex）"><a href="#读写锁（RWMutex）" class="headerlink" title="读写锁（RWMutex）"></a>读写锁（RWMutex）</h2><p>RWMutex 是一个 reader&#x2F;writer 互斥锁。RWMutex 在某一时刻只能由任意数量的 reader goroutine 持有，或者是只被单个的 writer goroutine 持有，适用于读多写少的场景。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ul><li>Lock&#x2F;Unlock：写操作时调用的方法</li><li>RLock&#x2F;RUnlock：读操作时调用的方法</li><li>RLocker：这个方法的作用是为读操作返回一个 Locker 接口的对象。它的 Lock 方法会调用 RWMutex 的 RLock 方法，它的 Unlock 方法会调用 RWMutex 的 RUnlock 方法。</li></ul><p>使用示例：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> counter Counter</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123; <span class="comment">// 10个reader</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                counter.Count() <span class="comment">// 计数器读操作</span></span><br><span class="line">                time.Sleep(time.Millisecond)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123; <span class="comment">// 一个writer</span></span><br><span class="line">        counter.Incr() <span class="comment">// 计数器写操作</span></span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一个线程安全的计数器</span></span><br><span class="line"><span class="keyword">type</span> Counter <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu    sync.RWMutex</span><br><span class="line">    count <span class="type">uint64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用写锁保护</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Counter)</span></span> Incr() &#123;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    c.count++</span><br><span class="line">    c.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用读锁保护</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Counter)</span></span> Count() <span class="type">uint64</span> &#123;</span><br><span class="line">    c.mu.RLock()</span><br><span class="line">    <span class="keyword">defer</span> c.mu.RUnlock()</span><br><span class="line">    <span class="keyword">return</span> c.count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="底层结构"><a href="#底层结构" class="headerlink" title="底层结构"></a>底层结构</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RWMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">  w           Mutex   <span class="comment">// 互斥锁解决多个writer的竞争</span></span><br><span class="line">  writerSem   <span class="type">uint32</span>  <span class="comment">// writer信号量</span></span><br><span class="line">  readerSem   <span class="type">uint32</span>  <span class="comment">// reader信号量</span></span><br><span class="line">  readerCount <span class="type">int32</span>   <span class="comment">// reader的数量（以及是否有 writer 竞争锁）</span></span><br><span class="line">  readerWait  <span class="type">int32</span>   <span class="comment">// writer等待完成的reader的数量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rwmutexMaxReaders = <span class="number">1</span> &lt;&lt; <span class="number">30</span></span><br></pre></td></tr></table></figure><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>一个 writer goroutine 获得了内部的互斥锁，就会反转 readerCount 字段，把它从原来的正整数 readerCount(&gt;&#x3D;0) 修改为负数（readerCount - rwmutexMaxReaders），让这个字段保持两个含义（既保存了 reader 的数量，又表示当前有 writer）。也就是说当readerCount为负数的时候表示当前writer goroutine持有写锁中，reader goroutine会进行阻塞。</p><p>当一个 writer 释放锁的时候，它会再次反转 readerCount 字段。可以肯定的是，因为当前锁由 writer 持有，所以，readerCount 字段是反转过的，并且减去了 rwmutexMaxReaders 这个常数，变成了负数。所以，这里的反转方法就是给它增加 rwmutexMaxReaders 这个常数值。</p><h3 id="易错场景"><a href="#易错场景" class="headerlink" title="易错场景"></a>易错场景</h3><ol><li>复制已经使用的读写锁，会把它的状态也给复制过来，原来的锁在释放的时候，并不会修改你复制出来的这个读写锁，这就会导致复制出来的读写锁的状态不对，可能永远无法释放锁</li><li>重入导致死锁，因为读写锁内部基于互斥锁实现对 writer 的并发访问，而互斥锁本身是有重入问题的，所以，writer 重入调用 Lock 的时候，就会出现死锁的现象</li><li>在 reader 的读操作时调用 writer 的写操作（调用 Lock 方法），那么，这个 reader 和 writer 就会形成互相依赖的死锁状态</li><li>当一个 writer 请求锁的时候，如果已经有一些活跃的 reader，它会等待这些活跃的 reader 完成，才有可能获取到锁，但是，如果之后活跃的 reader 再依赖新的 reader 的话，这些新的 reader 就会等待 writer 释放锁之后才能继续执行，这就形成了一个环形依赖： writer 依赖活跃的 reader -&gt; 活跃的 reader 依赖新来的 reader -&gt; 新来的 reader 依赖 writer</li><li>释放未加锁的 RWMutex，和互斥锁一样，Lock 和 Unlock 的调用总是成对出现的，RLock 和 RUnlock 的调用也必须成对出现。Lock 和 RLock 多余的调用会导致锁没有被释放，可能会出现死锁，而 Unlock 和 RUnlock 多余的调用会导致 panic</li></ol><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>两个或两个以上的进程（或线程，goroutine）在执行过程中，因争夺共享资源而处于一种互相等待的状态，如果没有外部干涉，它们都将无法推进下去，此时，我们称系统处于死锁状态或系统产生了死锁。</p><h2 id="产生死锁的四个必要条件"><a href="#产生死锁的四个必要条件" class="headerlink" title="产生死锁的四个必要条件"></a>产生死锁的四个必要条件</h2><ol><li>互斥：资源只能被一个goroutine持有，其他gouroutine必须等待，直到资源被释放</li><li>持有和等待：goroutine 持有一个资源，并且还在请求其它 goroutine 持有的资源</li><li>不可剥夺：资源只能由持有它的 goroutine 来释放</li><li>环路等待：多个等待goroutine（g1,g2,g3），g1等待g2的资源，g2等待g3的资源，g3等待g1的资源，形成环路等待的死结</li></ol><h2 id="如何解决死锁？（只需要打破必要条件其中一个即可避免死锁）"><a href="#如何解决死锁？（只需要打破必要条件其中一个即可避免死锁）" class="headerlink" title="如何解决死锁？（只需要打破必要条件其中一个即可避免死锁）"></a>如何解决死锁？（只需要打破必要条件其中一个即可避免死锁）</h2><ol><li>设置超时时间</li><li>避免使用多个锁</li><li>按照规定顺序申请锁</li><li>死锁检测</li></ol><h1 id="sync-Cond"><a href="#sync-Cond" class="headerlink" title="sync.Cond"></a>sync.Cond</h1><p>Cond 通常应用于等待某个条件的一组 goroutine，等条件变为 true 的时候，其中一个 goroutine 或者所有的 goroutine 都会被唤醒执行。</p><h2 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NeWCond</span><span class="params">(l Locker)</span></span> *Cond </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Broadcast() </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Signal() </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Wait()</span><br></pre></td></tr></table></figure><ul><li>Singal(): 唤醒一个等待此 Cond 的 goroutine</li><li>Broadcast(): 唤醒所有等待此 Cond 的 goroutine</li><li>Wait(): 放入 Cond 的等待队列中并阻塞，直到被 Signal 或者 Broadcast 的方法从等待队列中移除并唤醒，使用该方法是需要搭配满足条件</li></ul><p>使用示例：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := sync.NewCond(&amp;sync.Mutex&#123;&#125;)</span><br><span class="line">    <span class="keyword">var</span> ready <span class="type">int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            time.Sleep(time.Duration(rand.Int63n(<span class="number">10</span>)) * time.Second)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 加锁更改等待条件</span></span><br><span class="line">            c.L.Lock()</span><br><span class="line">            ready++</span><br><span class="line">            c.L.Unlock()</span><br><span class="line"></span><br><span class="line">            log.Printf(<span class="string">&quot;运动员#%d 已准备就绪\n&quot;</span>, i)</span><br><span class="line">            <span class="comment">// 广播唤醒所有的等待者</span></span><br><span class="line">            c.Broadcast()</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c.L.Lock()</span><br><span class="line">    <span class="keyword">for</span> ready != <span class="number">10</span> &#123;</span><br><span class="line">        c.Wait()</span><br><span class="line">        log.Println(<span class="string">&quot;裁判员被唤醒一次&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    c.L.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//所有的运动员是否就绪</span></span><br><span class="line">    log.Println(<span class="string">&quot;所有运动员都准备就绪。比赛开始，3，2，1, ......&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h1><p>channel用于goroutine之间的通信，go语言中，CSP并发模型，不要通过共享内存实现通信，而是通过通信实现共享内存，就是由goroutine和channel实现的。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li>数据交流</li><li>信号通知</li><li>任务编排</li><li>锁</li></ul><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>初始化</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>) <span class="comment">//有缓冲区</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>) <span class="comment">//无缓冲区</span></span><br></pre></td></tr></table></figure><p>发送数据</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- <span class="number">2</span></span><br></pre></td></tr></table></figure><p>接受数据</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x := &lt;-ch <span class="comment">// 把接收的一条数据赋值给变量x </span></span><br><span class="line">foo(&lt;-ch) <span class="comment">// 把接收的一个的数据作为参数传给函数 </span></span><br><span class="line">&lt;-ch <span class="comment">// 丢弃接收的一条数据</span></span><br></pre></td></tr></table></figure><h2 id="返回容量"><a href="#返回容量" class="headerlink" title="返回容量"></a>返回容量</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="built_in">cap</span>(ch)</span><br></pre></td></tr></table></figure><h2 id="返回channel中缓存的还未被取走的元素数量"><a href="#返回channel中缓存的还未被取走的元素数量" class="headerlink" title="返回channel中缓存的还未被取走的元素数量"></a>返回channel中缓存的还未被取走的元素数量</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">l := <span class="built_in">len</span>(ch)</span><br></pre></td></tr></table></figure><h2 id="关闭channel"><a href="#关闭channel" class="headerlink" title="关闭channel"></a>关闭channel</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure><h2 id="遍历channel"><a href="#遍历channel" class="headerlink" title="遍历channel"></a>遍历channel</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种</span></span><br><span class="line"><span class="keyword">var</span> ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>) </span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123; </span><br><span class="line">  <span class="keyword">select</span> &#123; </span><br><span class="line">  <span class="keyword">case</span> ch &lt;- i: </span><br><span class="line">  <span class="keyword">case</span> v := &lt;-ch: fmt.Println(v) </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种</span></span><br><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> ch &#123; </span><br><span class="line">  fmt.Println(v) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="底层结构-1"><a href="#底层结构-1" class="headerlink" title="底层结构"></a>底层结构</h2><p>qcount 已经接收但还未被取走的元素个数 内置函数len获取到</p><p>datasiz 循环队列的大小 暂时认为是cap容量的值</p><p>elemtype和elemsize 声明chan时到元素类型和大小 固定</p><p>buf 指向缓冲区的指针 无缓冲通道中 buf的值为nil</p><p>sendx 处理发送进来数据的指针在buf中的位置 接收到数据 指针会加上elemsize，移向下一个位置</p><p>recvx 处理接收请求（发送出去）的指针在buf中的位置</p><p>recvq 如果没有数据可读而阻塞， 会加入到recvq队列中</p><p>sendq 向一个满了的buf 发送数据而阻塞，会加入到sendq队列中</p><h2 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h2><p>向channel写数据的流程：</p><p>有缓冲区：<br>优先查看recvq是否为空，如果不为空，优先唤醒recvq的中goroutine，并写入数据；如果队列为空，则写入缓冲区，如果缓冲区已满则写入sendq队列；</p><p>无缓冲区：<br>直接写入sendq队列</p><p>向channel读数据的流程：</p><p>有缓冲区：优先查看缓冲区，如果缓冲区有数据并且未满，直接从缓冲区取出数据；<br>如果缓冲区已满并且sendq队列不为空，优先读取缓冲区头部的数据，并将队列的G的数据写入缓冲区尾部；</p><p>无缓冲区：将当前goroutine加入recvq队列，等到写goroutine的唤醒</p><h2 id="易错点"><a href="#易错点" class="headerlink" title="易错点"></a>易错点</h2><ul><li>channel未初始化，写入或者读取都会阻塞</li><li>往close的channel写入数据会发生panic</li><li>close未初始化channel会发生panic</li><li>close已经close过的channel会发生panic</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>swoole面试常见问题</title>
      <link href="/rainbow-bubbles/Technology/swoole%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <url>/rainbow-bubbles/Technology/swoole%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍swoole"><a href="#介绍swoole" class="headerlink" title="介绍swoole"></a>介绍swoole</h1><p>首先 swoole 是 php 的一个扩展程序，swoole 是一个为 php 用 c 和 c++ 编写的基于事件的高性能异步 &amp; 协程并行网络通信引擎。<br>swoole 是一个多进程模型的框架，当启动一个进程 swoole 应用时，一共会创建 2+n+m 个进程，n 为 worker 进程数，m 为 TaskWorker 进程数，1 个 master 进程和一个 manager 进程，关系如下图所示<br><img src="https://r2.721503.xyz/blog/1747295555838.png"></p><h2 id="Reactor-线程"><a href="#Reactor-线程" class="headerlink" title="Reactor 线程"></a>Reactor 线程</h2><ul><li>负责维护客户端 <code>TCP</code> 连接、处理网络 <code>IO</code>、处理协议、收发数据</li><li>完全是异步非阻塞的模式</li><li>全部为 <code>C</code> 代码，除 <code>Start/Shudown</code> 事件回调外，不执行任何 PHP 代码</li><li>将 <code>TCP</code> 客户端发来的数据缓冲、拼接、拆分成完整的一个请求数据包</li><li><code>Reactor</code> 以多线程的方式运行</li></ul><h2 id="Worker-进程"><a href="#Worker-进程" class="headerlink" title="Worker 进程"></a>Worker 进程</h2><ul><li>接受由 <code>Reactor</code> 线程投递的请求数据包，并执行 <code>PHP</code> 回调函数处理数据</li><li>生成响应数据并发给 <code>Reactor</code> 线程，由 <code>Reactor</code> 线程发送给 <code>TCP</code> 客户端</li><li>可以是异步非阻塞模式，也可以是同步阻塞模式</li><li>Worker 以多进程的方式运行</li></ul><h2 id="TaskWorker-进程"><a href="#TaskWorker-进程" class="headerlink" title="TaskWorker 进程"></a>TaskWorker 进程</h2><ul><li>接受由 Worker 进程通过 swoole_server-&gt;task&#x2F;taskwait方法投递的任务</li><li>处理任务，并将结果数据返回（使用 swoole_server-&gt;finish）给 Worker 进程</li><li>完全是同步阻塞模式</li><li>TaskWorker 以多进程的方式运行</li></ul><h2 id="网络通信引擎"><a href="#网络通信引擎" class="headerlink" title="网络通信引擎"></a>网络通信引擎</h2><p>网络通信引擎，是为 php 提供网络通信能力的，传统的 php 程序都是启动 php-fpm，前边再有一层 nginx 或者 apache，打开浏览器访问就 OK，但是从浏览器访问到服务器这一阶段涉及到了网络强求，但是这一阶段跟 php 脚本没有任何的关系，php 只需要处理好数据生成需要展示的内容就完成使命了，声明周期当中，请求到来前和请求完成后都没有 php 脚本什么事，而 swoole 提供的一大能力就是扩展了 php 的生命周期，无需 php-fpm 或者 nginx 或者 apache 之类的工具帮助就可以启动一个 web 服务，并且从服务启动前，启动后，链接进入，请求到来，请求结束，链接切断，服务终止都在 php 脚本的掌控之中，这样的话 php 脚本就会涉及到大量的网络通讯处理，而这个网络通讯处理的能力正是来源于 swoole! </p><h2 id="基于事件的高性能异步"><a href="#基于事件的高性能异步" class="headerlink" title="基于事件的高性能异步"></a>基于事件的高性能异步</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$data</span> = <span class="title function_ invoke__">file_contents</span>(<span class="string">&#x27;./data.json&#x27;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$data</span>;</span><br></pre></td></tr></table></figure><p>就拿读取文件内容来说吧，<code>ile_get_contents()</code> 执行完才能执行下边的代码 这样就很容易造成程序的阻塞。</p><p>否则下边的代码就无法输出文件的内容<br>传统 php 都是这样阻塞式的顺序执行的</p><p>这是常见的同步编程<br>异步：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">success</span>: <span class="keyword">function</span>(<span class="params">a</span>) &#123;</span><br><span class="line">        $.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">            <span class="attr">url</span>: <span class="string">&quot;bar&quot;</span>,</span><br><span class="line">            <span class="attr">data</span>: a,</span><br><span class="line">            <span class="attr">success</span>: <span class="keyword">function</span>(<span class="params">b</span>) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(b)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(lll)</span><br></pre></td></tr></table></figure><p>代码在执行到 ajax 的时候，函数会直接返回，你马上就可以看到屏幕上打印出的lll</p><p>这就是异步，这样你永远不会被 IO 阻塞，但是它带来了新的问题，在你运行到 lol 之后你就不知道现在代码运行到哪里去了，你只能等待回调被触发，然后屏幕上打印响应的 log, 它的执行不是单层顺序的，而是嵌套的<br>如果在业务代码当中 这样层层嵌套可读性可想而知<br>当然这是前端异步请求后端接口<br>swoole 当中处理异步回调嵌套使用的是协程<br>你知道什么叫协程吗？你知道线程是干啥的吗？你又知道进程吗？<br>如果想深入了解 swoole 的强大之处 你还得要了解传统 php 的 lnmp 环境的整套运行机制，这些你都了解吗？</p><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>通俗的说，协程就是一段段协作方式执行的程序，协作来完成一件事，协作就是协同作业。我们知道团队协同来做事，比个人单独来做事，效率肯定要高，因为团队协同可以发挥各成员的能动性、优势互补。这是拿人来比喻。我们拿做事来比喻举个例子：比如我们做饭，比如有以下环节洗菜、切菜、烧水、炒菜、煮米饭，人作为主体来操作，那么如果按部就班的做，先烧水，再洗菜，在切菜，再炒菜，再煮饭，那这顿饭要做很长时间比如总共 30 分钟吧，如果我们通过协同方式，先烧水，放灶火上就可以做其他洗菜、切菜的准备，再煮米饭，然后再来洗菜、切菜，再查看煮米饭，再炒菜，…，如此循环往复切换，最后水烧好，米饭也煮好了，菜也炒好了，饭也 OK 了，这样我们耗时可能只有 10-15 分钟，看到了吗，这就是生活中的 “协程”，由人来合理调度安排不同的环节，充分利用各种不同的资源和时间，来达到提高效率。协程是计算机程序，调用的则是不同的程序，处理者主要由 CPU 完成，处理对象是各种 IO 资源，处理的方式是不同的语言编写的程序。我们知道，CPU 可以调度不同的程序，让程序调用不同的 IO 资源，最初的进程是通过 CPU 频繁的切换来完成调用程序的，是操作系统按一定算法分配的时间片抢占被动方式来切换的，未考虑程序实际执行状况，这样切换程序会带来一定问题，而协程作为一种新的工作模式，可以让程序协作方式来执行，在需要使用 CPU 时，交给程序处理，遇到耗时的 IO 资源操作时会让出 CPU，交给处理其他程序，这样互相协作来执行，而不是抢占式的，就像交通规则，大家都遵守按一定规则礼让先行，不随便抢道，协同方式，程序都会执行的良好。</p><p>例子：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">go</span>(function () &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;hello go1 \n&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;hello main \n&quot;</span>;</span><br><span class="line"><span class="title function_ invoke__">go</span>(function () &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;hello go2 \n&quot;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">swoole# php co.php</span><br><span class="line">hello go1</span><br><span class="line">hello main</span><br><span class="line">hello go2</span><br></pre></td></tr></table></figure><p>执行结果和我们平时写代码的顺序，好像没啥区别。实际执行过程:</p><ul><li>运行此段代码，系统启动一个新进程</li><li>遇到 <code>go()</code>, 当前进程中生成一个协程，协程中输出 <code>heelo go1</code>, 协程退出</li><li>进程继续向下执行代码，输出 <code>hello main</code></li><li>再生成一个协程，协程中输出 <code>heelo go2</code>, 协程退出</li></ul><p>再看看这个例子：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="title">Co</span>;</span><br><span class="line"><span class="title function_ invoke__">go</span>(function () &#123;</span><br><span class="line"><span class="title class_">Co</span>::<span class="title function_ invoke__">sleep</span>(<span class="number">1</span>); <span class="comment">// 只新增了一行代码</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;hello go1 \n&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;hello main \n&quot;</span>;</span><br><span class="line"><span class="title function_ invoke__">go</span>(function () &#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;hello go2 \n&quot;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>输出结果：<br>\Co::sleep () 函数功能和 sleep () 差不多，但是它模拟的是 IO 等待 (IO 后面会细讲). </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">swoole<span class="comment"># php co.php</span></span><br><span class="line">hello main</span><br><span class="line">hello go2</span><br><span class="line">hello go1</span><br></pre></td></tr></table></figure><p>可以看出代码是异步执行的</p><h2 id="协程快在哪？减少-IO-阻塞导致的性能损失"><a href="#协程快在哪？减少-IO-阻塞导致的性能损失" class="headerlink" title="协程快在哪？减少 IO 阻塞导致的性能损失"></a>协程快在哪？减少 IO 阻塞导致的性能损失</h2><p>大家可能听到使用协程的最多的理由，可能就是 协程快. 那看起来和平时写得差不多的代码，为什么就要快一些呢？一个常见的理由是，可以创建很多个协程来执行任务，所以快. 这种说法是对的，不过还停留在表面。</p><h3 id="首先，一般的计算机任务分为-2-种："><a href="#首先，一般的计算机任务分为-2-种：" class="headerlink" title="首先，一般的计算机任务分为 2 种："></a>首先，一般的计算机任务分为 2 种：</h3><ul><li>CPU 密集型，比如加减乘除等科学计算</li><li>IO 密集型，比如网络请求，文件读写等<br>其次，高性能相关的 2 个概念：</li></ul><h3 id="并行：同一个时刻，同一个-CPU-只能执行同一个任务，要同时执行多个"><a href="#并行：同一个时刻，同一个-CPU-只能执行同一个任务，要同时执行多个" class="headerlink" title="并行：同一个时刻，同一个 CPU 只能执行同一个任务，要同时执行多个"></a>并行：同一个时刻，同一个 CPU 只能执行同一个任务，要同时执行多个</h3><ul><li>任务，就需要有多个 CPU 才行</li><li>并发：由于 CPU 切换任务非常快，快到人类可以感知的极限，就会有很多任务 同时执行 的错觉</li></ul><p>了解了这些，我们再来看协程，协程适合的是 IO 密集型 应用，因为协程在 IO 阻塞 时会自动调度，减少 IO 阻塞导致的时间损失！<br>协程在遇到 IO 阻塞的时候会让出 cpu 的控制权，其他协程拿到去执行其他协程的任务，当 IO 阻塞过去之后回过头来继续往下执行！</p><h3 id="要点："><a href="#要点：" class="headerlink" title="要点："></a>要点：</h3><ol><li>协程在阻塞的时候只是阻塞了当前这个协程 并不会阻塞整个的进程 因为协程是在线程内部的，即使阻塞了也会让出控制权，挂起，等待当前协程的 IO 不阻塞在回过头来继续执行，也就是同步的代码完成了异步的功能！相当强悍！</li><li>从宏观的角度看，程序员搞出来的多个协程在不发生任何协程阻塞的前提是是顺序执行的 一旦发生阻塞 你可以把多个协程理解为并行的 同时在执行的！</li><li>协程是在单进程单线程当中实现的 你可以在里面实现成千上万的协程 并且效果极高！ 每个协程去干不同的事！协作制的无需加锁没有抢占，串行的！什么叫串行呢？每次执行一个协程 遇到 IO 阻塞 挂起 执行接下来的程序 可能还是个协程 如果再遇到 IO 阻塞再挂起 继续往下执行 当 IO 阻塞完成回过头来继续往下执行没执行完的协程程序 每次都是一个协程在执行，串行化的！</li><li>协程之间每秒可以进行百万千万次切换！ 线程之间切换需要加锁 加锁就很浪费资源！进程间切换更浪费资源，因为上线很大。</li><li>协程很小切换还快 每秒百万千万级别的切换 所以 一个进程里面 只要你的内存够用 你就可以无止境的创造协程出来干事情！</li><li>事件驱动和异步为 swoole 提供了高性能 而协程解决了异步回调代码嵌套的问题 提高了代码可读性和维护性 也是 swoole 最大的特色！</li></ol><h2 id="协程之间通讯-channel"><a href="#协程之间通讯-channel" class="headerlink" title="协程之间通讯 channel"></a>协程之间通讯 channel</h2><p>通道（channel）是协程之间通信交换数据的唯一渠道，而协程 + 通道的开发组合即为著名的 csp 编程模型<br>在 swoole 当中 channel 常用于连接池的实现和协程并发的调度<br>如图所示 第一个协程执行完成之后我们会往 channel 通道当中 push 一个元素 第二个也是 当然第一个一定是 IO 阻塞的 第二个没有 我们在 for 循环里面 获取 channel 里面的值的时候由于第一个阻塞 chan−&gt;pop()也是阻塞的因为整体都是在一个协程里面只有当大的协程里面的两个小协程都完成了这里的chan-&gt;pop () 也是阻塞的 因为整体都是在一个协程里面 只有当大的协程里面的两个小协程都完成了 这里的 chan−&gt;pop()也是阻塞的因为整体都是在一个协程里面只有当大的协程里面的两个小协程都完成了这里的chan-&gt;pop 才会执行 接触阻塞 最后才会执行 echo 语句！ 这是 swoole 当中协程并发的一个很好的案例应用</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">use</span> <span class="title">Swoole</span>\<span class="title">Coroutine</span> <span class="keyword">as</span> <span class="title">co</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">query</span>(<span class="params"><span class="keyword">array</span> <span class="variable">$sql</span></span>)</span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">go</span>(function() &#123;</span><br><span class="line">    <span class="variable">$chan</span> = <span class="keyword">new</span> co\<span class="title function_ invoke__">Channel</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="title function_ invoke__">go</span>(function() <span class="keyword">use</span> ($<span class="title">chan</span>) &#123;</span><br><span class="line">        $<span class="title">var</span> = <span class="title">query</span>(...);</span><br><span class="line">        <span class="variable">$chan</span>-&gt;<span class="title function_ invoke__">push</span>(<span class="variable">$var</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">go</span>(function() <span class="keyword">use</span> ($<span class="title">chan</span>) &#123;</span><br><span class="line">        $<span class="title">var</span> = <span class="title">query</span>(...);</span><br><span class="line">        <span class="variable">$chan</span>-&gt;<span class="title function_ invoke__">push</span>(<span class="variable">$var</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="variable">$i</span>=<span class="number">0</span>; <span class="variable">$i</span>&lt;<span class="number">2</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">        <span class="variable">$chan</span>-&gt;<span class="title function_ invoke__">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;done&quot;</span> . PHP_EOL;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="毫秒定时器"><a href="#毫秒定时器" class="headerlink" title="毫秒定时器"></a>毫秒定时器</h2><p>毫秒定时器是异步回调的方式来实现的！<br>还可以使用协程方式 采用同步阻塞的方式来实现定时器！<br>之前用 sleep 会阻塞整个进程 现在你在协程里面搞 Co:sleep (0.1) 阻塞的是当前协程 而不会阻塞整个进程！</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">go</span>(function() &#123;</span><br><span class="line">    <span class="variable">$i</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="title class_">Co</span>::<span class="title function_ invoke__">sleep</span>(<span class="number">0.1</span>);</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;Do something...\n&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (++<span class="variable">$i</span> === <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;Done\n&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;All right!\n&quot;</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="swoole-提升性能"><a href="#swoole-提升性能" class="headerlink" title="swoole 提升性能"></a>swoole 提升性能</h1><ol><li>进程常驻内存：<br>swoole本⾝是进程常驻内存，在进程启动的时候就将PHP框架等代码读取并编译完成，不需要每次启动的时候都执⾏编译步骤，⼤⼤降低了脚本的运⾏时间；</li><li>连接池<br>php-fpm的模式php因为每次请求结束时都会销毁所有资源，因此⽆法使⽤连接池；⽽基于swoole的进程常驻内存模式，可以通过连接池的⽅式来加速程序，使⽤连接池既可以降低程序的响应时间，⼜可以有效保护后端资源。</li><li>可以使⽤协程处理异步IO<br>当开发中需要去请求多处的数据，⽽每⼀块的数据单独请求都要花较长时间，常规的php-fpm是阻塞式运⾏，⽆法对这类型的数据处理进⾏加速；⽽基于swoole的程序，可以将这类的业务并⾏化处理，并⾏去请求后端的数据源，能够⼤⼤优化了此类业务的运⾏时间。</li></ol><h1 id="swoole⾥的协程是什么，怎么⽤？为什么协程可以提⾼并发"><a href="#swoole⾥的协程是什么，怎么⽤？为什么协程可以提⾼并发" class="headerlink" title="swoole⾥的协程是什么，怎么⽤？为什么协程可以提⾼并发"></a>swoole⾥的协程是什么，怎么⽤？为什么协程可以提⾼并发</h1><p>协程是通过协作⽽不是抢占的⽅式来进⾏切换，它创建和切换对内存等资源⽐线程⼩的多(可以理解为更⼩的线程)；<br>协程的使⽤是通过Swoole\Coroutine或者Co\命名空间短命名简化类名来创建；<br>协程可以异步处理任务，⽀持并发，并且资源消耗⼩</p><h1 id="⽤了swoole以后，会不会发⽣内存泄漏？如果发⽣了怎么解决？"><a href="#⽤了swoole以后，会不会发⽣内存泄漏？如果发⽣了怎么解决？" class="headerlink" title="⽤了swoole以后，会不会发⽣内存泄漏？如果发⽣了怎么解决？"></a>⽤了swoole以后，会不会发⽣内存泄漏？如果发⽣了怎么解决？</h1><p>swoole由于是常驻内存，⼀旦资源加载进⼊后，会⼀直存在于内存中。对于局部变量，swoole会在回调函数结束后⾃动释放；对于全局变量(lobal声明的变量，static声明的对象属性或者函数内的静态变量和超全局变量)，swoole不会⾃动释放；因此操作不好会发⽣内存泄漏。<br>解决：</p><ol><li>在onClose的时候释放</li><li>在 Swoole 中，可以使用 max_request 和 task_max_request 来避免内存泄露<br>max_request：表示 worker 进程的最大任务数量，当 worker 进程处理的任务数量超过这个参数值时，worker 进程自动退出，如此就达到了释放内存和资源的目的<br>task_max_request：同 max_request 一样</li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 13-swoole-server.php</span></span><br><span class="line"> </span><br><span class="line"><span class="variable">$server</span> = <span class="keyword">new</span> <span class="title class_">Swoole\Server</span>(<span class="string">&#x27;0.0.0.0&#x27;</span>, <span class="number">9501</span>, SWOOLE_PROCESS);</span><br><span class="line"> </span><br><span class="line"><span class="variable">$server</span>-&gt;<span class="title function_ invoke__">set</span>([</span><br><span class="line">   <span class="string">&#x27;worker_num&#x27;</span>       =&gt; <span class="number">1</span>,</span><br><span class="line">   <span class="string">&#x27;task_worker_num&#x27;</span>  =&gt; <span class="number">1</span>,</span><br><span class="line">   <span class="string">&#x27;max_request&#x27;</span>      =&gt; <span class="number">2</span>,</span><br><span class="line">   <span class="string">&#x27;task_max_reqeust&#x27;</span> =&gt; <span class="number">2</span>,</span><br><span class="line">]);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="variable">$server</span>-&gt;<span class="title function_ invoke__">on</span>(<span class="string">&#x27;Receive&#x27;</span>, function (<span class="variable">$server</span>, <span class="variable">$fd</span>, <span class="variable">$fromId</span>, <span class="variable">$data</span>) &#123;</span><br><span class="line">   <span class="variable">$server</span>-&gt;<span class="title function_ invoke__">task</span>(<span class="variable">$data</span>);</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="variable">$server</span>-&gt;<span class="title function_ invoke__">on</span>(<span class="string">&#x27;Task&#x27;</span>, function (<span class="variable">$server</span>, <span class="variable">$taskId</span>, <span class="variable">$fromId</span>, <span class="variable">$data</span>) &#123;</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="variable">$server</span>-&gt;<span class="title function_ invoke__">on</span>(<span class="string">&#x27;Finish&#x27;</span>, function (<span class="variable">$server</span>, <span class="variable">$taskId</span>, <span class="variable">$data</span>) &#123;</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="variable">$server</span>-&gt;<span class="title function_ invoke__">start</span>();</span><br></pre></td></tr></table></figure><p>缺点:<br>max_request 只能用于同步阻塞，无状态的请求响应式服务<br>纯异步的server不应该设置max_request<br>使用Base模式时，max_request无效</p>]]></content>
      
      
      <categories>
          
          <category> 计算机技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> swoole </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP面试常见问题总结</title>
      <link href="/rainbow-bubbles/Technology/PHP%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/rainbow-bubbles/Technology/PHP%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="PHP面试常见问题总结"><a href="#PHP面试常见问题总结" class="headerlink" title="PHP面试常见问题总结"></a>PHP面试常见问题总结</h1><blockquote><p>部分题目收集自网络</p></blockquote><h2 id="1-echo-print-print-r-var-dump-的区别？"><a href="#1-echo-print-print-r-var-dump-的区别？" class="headerlink" title="1. echo(),print(),print_r(),var_dump()的区别？"></a>1. echo(),print(),print_r(),var_dump()的区别？</h2><p>echo 和 print 只能打印出string，不能打印出结构；<br><code>print(string $arg)</code>只有一个参数;<br><code>echo arg1,arg2</code> 可以输出多个参数;<br><code>print_r</code>和<code>var_dump</code>能打印出结构。比如:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$arr</span> = <span class="keyword">array</span>(<span class="string">&quot;key&quot;</span>=&gt;<span class="string">&quot;value&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="variable">$arr</span>);</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(arr);</span><br></pre></td></tr></table></figure><p><code>print_r</code>和<code>var_dump</code>区别:<br>print_r() 只能打印一些易于理解的信息，且print_r()在打印数组时，会将把数组的指针移到最后边，使用reset() 可让指针回到开始处。 而var_dump()不但能打印复合类型的数据，还能打印资源类型的变量</p><h2 id="2-语句include和require的区别是什么"><a href="#2-语句include和require的区别是什么" class="headerlink" title="2. 语句include和require的区别是什么?"></a>2. 语句include和require的区别是什么?</h2><p>在失败的时候：<br><code>include</code> 产生一个 warning ，而 require 直接产生错误中断；<br><code>require</code> 在运行前载入；<br><code>include</code> 在运行时载入；<br><code>require_once</code> 和 <code>include_once</code> 可以避免重复包含同一文件。</p><h2 id="3-php中传值与传引用有啥区别"><a href="#3-php中传值与传引用有啥区别" class="headerlink" title="3. php中传值与传引用有啥区别?"></a>3. php中传值与传引用有啥区别?</h2><p>&amp;表示传引用；<br>函数中参数传引用会将参数进行改变；<br>一般在输出参数有多个的时候可以考虑使用引用。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$num</span> = <span class="number">10</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">&amp;<span class="variable">$num</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$num</span> = <span class="variable">$num</span> * <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">multiply</span>(<span class="variable">$num</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$num</span>;</span><br></pre></td></tr></table></figure><h2 id="4-下面哪项没有将john添加到users数组中？"><a href="#4-下面哪项没有将john添加到users数组中？" class="headerlink" title="4. 下面哪项没有将john添加到users数组中？"></a>4. 下面哪项没有将john添加到users数组中？</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(a) <span class="variable">$users</span>[] = <span class="string">&#x27;john&#x27;</span>;</span><br><span class="line">(b) <span class="title function_ invoke__">array_add</span>(<span class="variable">$users</span>,<span class="string">&#x27;john&#x27;</span>);</span><br><span class="line">(c) <span class="title function_ invoke__">array_push</span>(<span class="variable">$users</span>,<span class="string">&#x27;john&#x27;</span>);</span><br><span class="line">(d) <span class="variable">$users</span> ||= <span class="string">&#x27;john&#x27;</span>;</span><br></pre></td></tr></table></figure><p>答案为bd，php 里面无 array_add 函数，d项为语法错误的表达;</p><h2 id="5-HTTP协议中几个状态码的含义。"><a href="#5-HTTP协议中几个状态码的含义。" class="headerlink" title="5. HTTP协议中几个状态码的含义。"></a>5. HTTP协议中几个状态码的含义。</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">200 : 请求成功，请求的数据随之返回。</span><br><span class="line">301 : 永久性重定向。</span><br><span class="line">302 : 暂时行重定向。</span><br><span class="line">401 : 当前请求需要用户验证。</span><br><span class="line">403 : 服务器拒绝执行请求，即没有权限。</span><br><span class="line">404 : 请求失败，请求的数据在服务器上未发现。</span><br><span class="line">500 : 服务器错误。一般服务器端程序执行错误。</span><br><span class="line">503 : 服务器临时维护或过载。这个状态时临时性的。</span><br></pre></td></tr></table></figure><h2 id="6-一些php魔术方法。"><a href="#6-一些php魔术方法。" class="headerlink" title="6. 一些php魔术方法。"></a>6. 一些php魔术方法。</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">__construct() 实例化类时自动调用。</span><br><span class="line">__destruct() 类对象使用结束时自动调用。</span><br><span class="line">__set() 在给未定义的属性赋值的时候调用。</span><br><span class="line">__get() 调用未定义的属性时候调用。</span><br><span class="line">__isset() 使用isset()或empty()函数时候会调用。</span><br><span class="line">__unset() 使用unset()时候会调用。</span><br><span class="line">__sleep() 使用serialize序列化时候调用。</span><br><span class="line">__wakeup() 使用unserialize反序列化的时候调用。</span><br><span class="line">__call() 调用一个不存在的方法的时候调用。</span><br><span class="line">__callStatic()调用一个不存在的静态方法是调用。</span><br><span class="line">__toString() 把对象转换成字符串的时候会调用。比如 echo。</span><br><span class="line">__invoke() 当尝试把对象当方法调用时调用。</span><br><span class="line">__set_state() 当使用var_export()函数时候调用。接受一个数组参数。</span><br><span class="line">__clone() 当使用clone复制一个对象时候调用。</span><br></pre></td></tr></table></figure><h2 id="7-MySQL存储引擎-MyISAM-和-InnoDB-的区别。"><a href="#7-MySQL存储引擎-MyISAM-和-InnoDB-的区别。" class="headerlink" title="7. MySQL存储引擎 MyISAM 和 InnoDB 的区别。"></a>7. MySQL存储引擎 MyISAM 和 InnoDB 的区别。</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a. MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持.</span><br><span class="line">b. MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快.</span><br><span class="line">c. InnoDB不支持FULLTEXT类型的索引.</span><br><span class="line">d. InnoDB中不保存表的具体行数，也就是说，执行select count(*) from table时，InnoDB要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可.</span><br><span class="line">e. 对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引。</span><br><span class="line">f. DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除。</span><br><span class="line">g. LOAD TABLE FROM MASTER操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性(例如外键)的表不适用.</span><br><span class="line">h. MyISAM支持表锁，InnoDB支持行锁。</span><br></pre></td></tr></table></figure><h2 id="8-说出一些MySQL优化方法？"><a href="#8-说出一些MySQL优化方法？" class="headerlink" title="8. 说出一些MySQL优化方法？"></a>8. 说出一些MySQL优化方法？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a. 设计良好的数据库结构，允许部分数据冗余，尽量避免join查询，提高效率。</span><br><span class="line">b. 选择合适的表字段数据类型和存储引擎，适当的添加索引。</span><br><span class="line">c. mysql库主从读写分离。</span><br><span class="line">d. 找规律分表，减少单表中的数据量提高查询速度。</span><br><span class="line">e. 添加缓存机制，比如memcached，apc等。</span><br><span class="line">f. 不经常改动的页面，生成静态页面。</span><br><span class="line">g. 书写高效率的SQL。比如 SELECT * FROM TABEL 改为 SELECT field_1, field_2, field_3 FROM TABLE.</span><br></pre></td></tr></table></figure><h2 id="9-说下php中empty-和isset-的区别。"><a href="#9-说下php中empty-和isset-的区别。" class="headerlink" title="9. 说下php中empty()和isset()的区别。"></a>9. 说下php中empty()和isset()的区别。</h2><p><code>isset</code> 用于检测变量是否被设置，使用 <code>isset()</code> 测试一个被设置成 <code>NULL</code> 的变量，将返回 <code>FALSE</code> 。<br><code>empty</code> 如果 <code>var</code> 是非空或非零的值，则 <code>empty()</code> 返回 <code>FALSE</code>。换句话说，<code>&quot;&quot;、0、&quot;0&quot;、NULL、FALSE、array()、var $var</code>; 以及没有任何属性的对象都将被认为是空的，如果 <code>var</code> 为空，则返回 <code>TRUE</code> 。</p><h2 id="10-for与foreach哪个更快"><a href="#10-for与foreach哪个更快" class="headerlink" title="10. for与foreach哪个更快?"></a>10. for与foreach哪个更快?</h2><p><code>foreach</code> 的效率要比 <code>for</code> 高很多，也许有很大的一个原因是 <code>for</code> 要进行很多次条件判断。所以以后能用 <code>foreach</code> 的地方就用 <code>foreach</code> ，可以提高1倍的效率。<br>如果循环内要调用函数，用 <code>array_walk</code> 最好，它的效率要比 <code>for</code> 高出1倍，要比 <code>foreach</code> 高出43%的效率。</p><h2 id="11-PECL-和-PEAR-有什么区别？"><a href="#11-PECL-和-PEAR-有什么区别？" class="headerlink" title="11. PECL 和 PEAR 有什么区别？"></a>11. PECL 和 PEAR 有什么区别？</h2><p><code>PECL (PHP Extension Community Library)</code> 可以看作 <code>PEAR (PHP Extension and Application Repository)</code> 的一个组成部分，提供了与 <code>PEAR</code> 类似的功能。不同的是 <code>PEAR</code> 的所有扩展都是用纯粹的 PHP 代码编写的，用户在下载到 PEAR 扩展以后可以直接使用将扩展的代码包含到自己的 PHP 文件中使用。而 PECL 是使用 C 语言开发的，通常用于补充一些用 PHP 难以完成的底层功能，往往需要重新编译或者在配置文件中设置后才能在用户自己的代码中使用。</p><p>最直接的表述：<code>PEAR</code> 是 PHP 的上层扩展，<code>PECL</code> 是 PHP 的底层扩展。它们都是为特定的应用提供现成的函数或者类。</p><h2 id="12-如何处理多服务器共享-Session"><a href="#12-如何处理多服务器共享-Session" class="headerlink" title="12. 如何处理多服务器共享 Session ?"></a>12. 如何处理多服务器共享 Session ?</h2><p>大致上有三种方式可以处理：</p><ul><li>数据库&#x2F;文件同步 session</li><li>cookie 同步 session</li><li>缓存 (如 <code>redis</code> ）同步 session</li></ul><h2 id="13-PHP内存管理机制与垃圾回收机制"><a href="#13-PHP内存管理机制与垃圾回收机制" class="headerlink" title="13. PHP内存管理机制与垃圾回收机制?"></a>13. PHP内存管理机制与垃圾回收机制?</h2><p><code>php</code> 的内存管理机制是：预先给出一块空间，用来存储变量，当空间不够时，再申请一块新的空间。</p><ul><li>存储变量名，存在符号表。</li><li>变量值存储在内存空间。</li><li>在删除变量的时候，会将变量值存储的空间释放，而变量名所在的符号表不会减小。</li></ul><p><code>php</code> 垃圾回收机制是：</p><ul><li>在5.2版本或之前版本，PHP会根据 引用计数 （ refcount ）值来判断是不是垃圾，如果refcount值为0，PHP会当做垃圾释放掉，这种回收机制有缺陷，对于环状引用的变量无法回收。</li><li>在5.3之后版本改进了垃圾回收机制。具体如下：<br>如果发现一个 <code>zval</code> 容器中的 <code>refcount</code> 在增加，说明不是垃圾； 如果发现一个 <code>zval</code> 容器中的 refcount 在减少，如果减到了0，直接当做垃圾回收； 如果发现一个 <code>zval</code> 容器中的 <code>refcount</code> 在减少，并没有减到0，PHP 会把该值放到缓冲区，当做有可能是垃圾的怀疑对象； 当缓冲区达到了临界值，PHP 会自动调用一个方法去遍历每一个值，如果发现是垃圾就清理。</li></ul><h2 id="14-多线程和多进程的区别为？"><a href="#14-多线程和多进程的区别为？" class="headerlink" title="14. 多线程和多进程的区别为？"></a>14. 多线程和多进程的区别为？</h2><p>进程是程序在计算机上的一次执行活动。当你运行一个程序，你就启动了一个进程。显然，程序是死的(静态的)，进程是活的(动态的)。进程可以分为系统进程和用户进程。凡是用于完成操作系统的各种功能的进程就是系统进程，它们就是处于运行状态下的操作系统本身；所有由你启动的进程都是用户进程。进程是操作系统进行资源分配的单位。在 Windows 下，进程又被细化为线程，也就是一个进程下有多个能独立运行的更小的单位。</p><h2 id="15-TCP-IP-网络协议，OSI-7-层指是什么？"><a href="#15-TCP-IP-网络协议，OSI-7-层指是什么？" class="headerlink" title="15. TCP&#x2F;IP 网络协议，OSI 7 层指是什么？"></a>15. TCP&#x2F;IP 网络协议，OSI 7 层指是什么？</h2><p><code>TCP/IP</code> 5层 指的是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">应用层</span><br><span class="line">HTTP、FTP、SMTP、DNS、DSP、Telnet、Gopher、WAIS……</span><br><span class="line">传输层</span><br><span class="line">TCP、UDP、DVP……</span><br><span class="line">网络层</span><br><span class="line">IP、ICMP、AKP、RARP、UUCP……</span><br><span class="line">接口层</span><br><span class="line">Ethernet、Arpanet、PDN……</span><br><span class="line">物理层</span><br><span class="line">只要能传输IP数据报（Datagram），允许任何协议……</span><br></pre></td></tr></table></figure><p><code>OSI</code> 7层指的是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">应用层 文件传输，电子邮件，文件服务，虚拟终端 TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet</span><br><span class="line">表示层 数据格式化，代码转换，数据加密 没有协议</span><br><span class="line">会话层 解除或建立与别的接点的联系 没有协议</span><br><span class="line">传输层 提供端对端的接口 TCP，UDP</span><br><span class="line">网络层 为数据包选择路由 IP，ICMP，RIP，OSPF，BGP，IGMP</span><br><span class="line">数据链路层 传输有地址的帧以及错误检测功能 SLIP，CSLIP，PPP，ARP，RARP，MTU</span><br><span class="line">物理层 以二进制数据形式在物理媒体上传输数据 ISO2110，IEEE802，IEEE802.2</span><br></pre></td></tr></table></figure><h2 id="16-laravel-市场目前比较流行的框架"><a href="#16-laravel-市场目前比较流行的框架" class="headerlink" title="16. laravel 市场目前比较流行的框架"></a>16. laravel 市场目前比较流行的框架</h2><ul><li><p>简述 Laravel 的生命周期</p><blockquote><p>Laravel 采用了单一入口模式，应用的所有请求入口都是 public&#x2F;index.php 文件。</p><ol><li>注册类文件自动加载器 : Laravel通过 composer 进行依赖管理，无需开发者手动导入各种类文件，而由自动加载器自行导入。</li><li>创建服务容器：从 bootstrap&#x2F;app.php 文件中取得 Laravel 应用实例 $app (服务容器)</li><li>创建 HTTP &#x2F; Console 内核：传入的请求会被发送给 HTTP 内核或者 console 内核进行处理</li><li>载入服务提供者至容器：<br>在内核引导启动的过程中最重要的动作之一就是载入服务提供者到你的应用，服务提供者负责引导启动框架的全部各种组件，例如数据库、队列、验证器以及路由组件。<blockquote><ol start="5"><li>分发请求：一旦应用完成引导和所有服务提供者都注册完成，Request 将会移交给路由进行分发。路由将分发请求给一个路由或控制器，同时运行路由指定的中间件</li></ol></blockquote></li></ol></blockquote></li><li><p>服务提供者是什么？</p><blockquote><p>服务提供者是所有 Laravel 应用程序引导启动的中心, Laravel 的核心服务器、注册服务容器绑定、事件监听、中间件、路由注册以及我们的应用程序都是由服务提供者引导启动的。</p></blockquote></li><li><p>IoC 容器是什么？</p><blockquote><p>IoC（Inversion of Control）译为 「控制反转」，也被叫做「依赖注入」(DI)。什么是「控制反转」？对象 A 功能依赖于对象 B，但是控制权由对象 A 来控制，控制权被颠倒，所以叫做「控制反转」，而「依赖注入」是实现 IoC 的方法，就是由 IoC 容器在运行期间，动态地将某种依赖关系注入到对象之中。</p><p>其作用简单来讲就是利用依赖关系注入的方式，把复杂的应用程序分解为互相合作的对象，从而降低解决问题的复杂度，实现应用程序代码的低耦合、高扩展。</p><p>Laravel 中的服务容器是用于管理类的依赖和执行依赖注入的工具。</p></blockquote></li><li><p>Facades 是什么？</p><blockquote><p>Facades（一种设计模式，通常翻译为外观模式）提供了一个”static”（静态）接口去访问注册到 IoC 容器中的类。提供了简单、易记的语法，而无需记住必须手动注入或配置的长长的类名。此外，由于对 PHP 动态方法的独特用法，也使测试起来非常容易。</p></blockquote></li><li><p>Contract 是什么？</p><blockquote><p>Contract（契约）是 laravel 定义框架提供的核心服务的接口。Contract 和 Facades 并没有本质意义上的区别，其作用就是使接口低耦合、更简单。</p></blockquote></li><li><p>谈谈 Laravel 和 YII 框架的区别.</p><blockquote><ol><li>在 YII 框架中的路由是通过书写 Controller、Action 间接定义路由，而 Laravel 中是在 route 路由文件中直接定义路由入口</li><li>Laravel 提供 ORM 对象关系映射，使读写数据库的操作更加简单</li><li>Laravel 提供更多的 Artisan 命令和脚手架开发</li><li>Laravel 的 Composer 扩展包比 Yii 框架更多，开发更加高效</li></ol></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu安装php</title>
      <link href="/rainbow-bubbles/Technology/Ubuntu%E5%AE%89%E8%A3%85php/"/>
      <url>/rainbow-bubbles/Technology/Ubuntu%E5%AE%89%E8%A3%85php/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /># PHP是什么语言？PHP 是一种服务器端编程语言，对用户免费且开源，也可用于制作各种类型的应用程序、网站、CRM 等等。它是一种经常使用的通用语言，可以集成到超文本标记语言 （HTML） 中。基本上在系统中，PHP 提供的八种原始数据类型进一步分为三个内部类别：脚本类型（预先建立）、化合物类型（用户定义）和唯一类型。<h1 id="如何在-Ubuntu-上安装-PHP？"><a href="#如何在-Ubuntu-上安装-PHP？" class="headerlink" title="如何在 Ubuntu 上安装 PHP？"></a>如何在 Ubuntu 上安装 PHP？</h1><p>Ubuntu 被称为最常用的开源作系统之一，它负责我们想要开发的应用程序的任何 Web 界面的整体开发，我们将在 Ubuntu 上安装 PHP 并了解在 Ubuntu 上安装 PHP 是多么容易</p><p>我们可以通过两种方法在 Ubuntu 上安装 PHP，让我们了解每种方法：</p><p>使用 apt&#x2F;terminal 安装 PHP</p><ol><li>更新apt</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><p>输出如下：<br><img src="https://r2.721503.xyz/blog/1747213337546.png"></p><ol><li>安装 PHP 软件包</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install php php-cli php-fpm php-json php-common php-mysql php-zip php-gd php-mbstring php-curl php-xml php-pear php-bcmath</span><br></pre></td></tr></table></figure><p>输出如下：确认提示，输入Y<br><img src="https://r2.721503.xyz/blog/1747213522748.png"></p><ol><li>检查是否安装了 PHP</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php -v</span><br></pre></td></tr></table></figure><p>输出如下：看到这个提示代表你已经安装成功<br><img src="https://r2.721503.xyz/blog/1747213640263.png"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建Hexo博客</title>
      <link href="/rainbow-bubbles/Technology/%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2/"/>
      <url>/rainbow-bubbles/Technology/%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="搭建Hexo博客"><a href="#搭建Hexo博客" class="headerlink" title="搭建Hexo博客"></a>搭建Hexo博客</h1><p>本文介绍如何使用hexo搭建个人博客，并将博客部署到Github Pages和Cloudflare Pages上。主要内容包括：</p><ul><li>环境准备：安装Node.js和Git</li><li>配置Git和Github：设置SSH密钥，创建Github仓库</li><li>初始化Hexo项目：安装Hexo，创建一篇博文</li><li>部署到GitHub Pages：配置部署设置，推送静态文件</li><li>部署到Cloudflare Pages：连接GitHub仓库，自动部署</li><li>基本使用方法：创建新文章，本地预览，发布更新</li></ul><p>这个教程适合那些想要快速搭建个人博客，但又不想花费太多成本的人。通过使用Hexo、GitHub和Cloudflare的免费服务，您可以轻松创建一个高效、简洁的博客网站。</p><h2 id="1-事前准备"><a href="#1-事前准备" class="headerlink" title="1. 事前准备"></a>1. 事前准备</h2><ol><li>域名(非必须，可以使用免费域名或者<code>Github.io</code>或者<code>Pages.dev</code>分配域名)</li><li><a href="https://github.com/">Github</a>（必须，你需要注册一个GitHub帐号）</li><li><a href="https://dash.cloudflare.com/">Cloudflare</a>（非必须，你需要注册一个Cloudflare帐号，这样你就可以将博客部署在CF的CDN里加速，但是你也可以直接使用<code>GitHub.io</code>分配的域名）</li></ol><h2 id="2-软件支持"><a href="#2-软件支持" class="headerlink" title="2. 软件支持"></a>2. 软件支持</h2><ol><li><a href="#21-%E5%AE%89%E8%A3%85-node">Node</a>(必须)</li><li><a href="Git"></a>(必须)</li><li><a href="vscode">https://code.visualstudio.com/</a>(非必须，这是一款轻量型的代码编辑器)</li></ol><h3 id="2-1-安装-Node"><a href="#2-1-安装-Node" class="headerlink" title="2.1. 安装 Node"></a>2.1. 安装 Node</h3><ol><li>打开Node官网，下载和自己系统相配的Node的安装程序，否则会出现安装问题。下载地址：<a href="https://nodejs.org/en">https://nodejs.org/en</a></li><li>下载后安装，安装的目录可以使用默认目录</li><li>安装完成后，检查是否安装成功。在键盘按下win + R键，输入CMD，然后回车，打开CMD窗口，执行<code>node -v</code>命令，看到版本信息，则说明安装成功。</li><li>修改npmmd源。npm下载各种模块，默认是从国处服务器下载，速度较慢，建议配置成华为云镜像源。打开CMD窗口，运行如下命令:</li></ol><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://mirrors.huaweicloud.com/repository/npm/</span><br></pre></td></tr></table></figure><h3 id="2-2-安装-Git"><a href="#2-2-安装-Git" class="headerlink" title="2.2. 安装 Git"></a>2.2. 安装 Git</h3><ol><li>进入官网下载适合你当前系统的 Git：<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a></li><li>下载后傻瓜式安装Git即可，安装的目录最好使用默认目录</li></ol><h2 id="3-配置-Git-密钥并连接至-Github"><a href="#3-配置-Git-密钥并连接至-Github" class="headerlink" title="3. 配置 Git 密钥并连接至 Github"></a>3. 配置 Git 密钥并连接至 Github</h2><p>常用 Git 命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config -l  //查看所有配置</span><br><span class="line">git config --system --list //查看系统配置</span><br><span class="line">git config --global --list //查看用户（全局）配置</span><br></pre></td></tr></table></figure><h3 id="3-1-配置用户名和邮箱"><a href="#3-1-配置用户名和邮箱" class="headerlink" title="3.1. 配置用户名和邮箱"></a>3.1. 配置用户名和邮箱</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;你的用户名&quot;</span><br><span class="line">git config --global user.email &quot;你的邮箱&quot;</span><br></pre></td></tr></table></figure><p>通过<code>git config -l</code>检查是否配置成功</p><h3 id="3-2-配置公钥连接Github"><a href="#3-2-配置公钥连接Github" class="headerlink" title="3.2. 配置公钥连接Github"></a>3.2. 配置公钥连接Github</h3><ol><li>执行以下命令生成ssh公钥，此公钥用于你的计算机连接Github</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;你的邮箱&quot;</span><br></pre></td></tr></table></figure><p>提示<code>Enter file in which to save the key</code>直接一路回车即可，新手小白不推荐设置密钥<br>之后打开C盘下用户文件夹下的.ssh的文件夹，会看到以下文件<br><img src="https://r2.721503.xyz/blog/1747630428012.png"><br>打开公钥文件就可以看到公钥<br><img src="https://r2.721503.xyz/blog/1747630914469.png"></p><ol start="2"><li>将 SSH KEY 配置到 GitHub<br>进入github，点击右上角头像 选择<code>settings</code>，进入设置页后选择<code>SSH and GPG keys</code>，名字随便起，公钥填到<code>Key</code>那一栏。<br><img src="https://r2.721503.xyz/blog/1747632411918.png"><br><img src="https://r2.721503.xyz/blog/1747632209953.png"><br><img src="https://r2.721503.xyz/blog/1747632257402.png"></li><li>测试连接，输入以下命令</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><h3 id="3-3-创建GitHub-io仓库"><a href="#3-3-创建GitHub-io仓库" class="headerlink" title="3.3. 创建GitHub.io仓库"></a>3.3. 创建GitHub.io仓库</h3><ol><li>点击右上角的<code>+</code>按钮，选择<code>New repository</code>，创建一个<code>&lt;用户名&gt;.github.io</code>的仓库。</li><li>仓库名字的格式必须为：<code>&lt;用户名&gt;.github.io</code> (注意：前缀必须为用户名，此为预览博客需要，后期可修改仓库名)</li><li>可见性必须选择 <code>Public</code> 方便第一次部署检查问题，点击 <code>Creat repository</code> 进行创建即可，我已经创建过了，所以提示已经存在。<br><img src="https://r2.721503.xyz/blog/1747632712447.png"></li></ol><h2 id="4-初始化-Hexo-博客"><a href="#4-初始化-Hexo-博客" class="headerlink" title="4. 初始化 Hexo 博客"></a>4. 初始化 Hexo 博客</h2><ol><li>创建一个文件夹来保存博客源码</li><li>在控制台使用下列命令安装Hexo</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli &amp;&amp; hexo -v</span><br></pre></td></tr></table></figure><ol start="3"><li>安装完后输入<code>hexo -v</code>验证是否安装成功。<br><img src="https://r2.721503.xyz/blog/1747632999229.png"></li><li>初始化 Hexo 项目安装相关依赖。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog-demo</span><br><span class="line">cd blog-demo</span><br><span class="line">npm i</span><br></pre></td></tr></table></figure><ol start="5"><li>初始化项目后，blog有如下结构：<br><img src="https://r2.721503.xyz/blog/1747633070813.png"></li></ol><ul><li><strong>node_modules</strong>：依赖包</li><li><strong>scaffolds</strong>：生成文章的一些模板</li><li><strong>source</strong>：用来存放你的文章</li><li><strong>themes</strong>：主题</li><li><strong>.npmignore</strong>：发布时忽略的文件（可忽略）</li><li><strong>_config.landscape.yml</strong>：主题的配置文件</li><li><strong>config.yml</strong>：博客的配置文件</li><li><strong>package.json</strong>：项目名称、描述、版本、运行和开发等信</li></ul><ol start="6"><li>启动项目</li></ol><ul><li>输入<code>hexo cl &amp;&amp; hexo s</code>启动项目<br><img src="https://r2.721503.xyz/blog/1747633313344.png"></li></ul><ol start="7"><li>打开浏览器，输入地址：<code>http://localhost:4000/</code> ，看到下面的效果，说明你的博客已经构建成功了。</li></ol><h2 id="5-将静态博客挂载到-GitHub-Pages"><a href="#5-将静态博客挂载到-GitHub-Pages" class="headerlink" title="5. 将静态博客挂载到 GitHub Pages"></a>5. 将静态博客挂载到 GitHub Pages</h2><ol><li>安装 hexo-deployer-git</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><ol start="2"><li>修改 <code>_config.yml</code> 文件<br>修改最后一行的配置，将repository修改为你自己的github项目地址即可，还有分支要改为<code>main</code>代表主分支（注意缩进）。</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">git@github.com:cmliussss2024/cmliussss2024.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure><ol start="3"><li>修改好配置后，运行如下命令，将代码部署到 GitHub（Hexo三连）。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Git BASH终端</span><br><span class="line">hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy  </span><br><span class="line">// 或者使用下面的</span><br><span class="line">// VSCODE终端</span><br><span class="line">hexo cl; hexo g; hexo d</span><br></pre></td></tr></table></figure><p>命令说明：</p><ul><li>hexo clean：删除之前生成的文件，可以用<code>hexo cl</code>缩写。</li><li>hexo generate：生成静态文章，可以用<code>hexo g</code>缩写</li><li>hexo deploy：部署文章，可以用<code>hexo d</code>缩写<br>如果出现<code>Deploy done</code>，则说明部署成功了。<br><img src="https://r2.721503.xyz/blog/1747633817493.png"><br>稍等两分钟，打开浏览器访问：<a href="https://github名字.github.io/">https://GitHub名字.github.io</a> ，这时候我们就可以看到博客内容了。</li></ul><h2 id="6-将静态博客挂载到-Cloudflare-Pages"><a href="#6-将静态博客挂载到-Cloudflare-Pages" class="headerlink" title="6.将静态博客挂载到 Cloudflare Pages"></a>6.将静态博客挂载到 Cloudflare Pages</h2><ol><li>在 <code>Workers 和 Pages</code> 中选择 <code>Pages</code> 的 <code>连接到 Git</code><br><img src="https://r2.721503.xyz/blog/1747634032359.png"><br><img src="https://r2.721503.xyz/blog/1747634067409.png"></li><li>然后登录你Blog仓库对应的GitHub帐号<br><img src="https://r2.721503.xyz/blog/1747634189446.png"></li><li>点击<code>保存并部署</code>后等待部署完成即可。<br><img src="https://r2.721503.xyz/blog/1747634327454.png"></li><li>提示成功！您的项目已部署到以下区域：全球后，浏览器访问：<a href="https://github名字-github-io.pages.dev/">https://github名字-github-io.pages.dev</a> ，这时候我们就可以看到博客内容了。<br><img src="https://r2.721503.xyz/blog/1747634457966.png"><br>这时你也就可以将你的<code>&lt;用户名&gt;.github.io</code>的仓库设置为<code>Private</code>私库了</li><li>如果你有自己的域名，你可以在这里绑定你自己的自定义域，即可<br><img src="https://r2.721503.xyz/blog/1747634564607.png"></li></ol><hr><h1 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h1><h2 id="新建一篇博文"><a href="#新建一篇博文" class="headerlink" title="新建一篇博文"></a>新建一篇博文</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new 这是一篇新的博文</span><br></pre></td></tr></table></figure><p>然后用文本编辑器去编辑<code>_posts/这是一篇新的博文.md</code>里的内容即可，注意要使用<code>Markdown</code>格式书写。<br>详细使用方法可以查阅 <a href="https://hexo.io/zh-cn/docs/writing">https://hexo.io/zh-cn/docs/writing</a></p><h3 id="编辑完文章保存后可以使用如下命令，生成本地页面-http-localhost-4000-，进行预览"><a href="#编辑完文章保存后可以使用如下命令，生成本地页面-http-localhost-4000-，进行预览" class="headerlink" title="编辑完文章保存后可以使用如下命令，生成本地页面 http://localhost:4000/ ，进行预览"></a>编辑完文章保存后可以使用如下命令，生成本地页面 <a href="http://localhost:4000/">http://localhost:4000/</a> ，进行预览</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Git BASH终端</span><br><span class="line">hexo cl &amp;&amp; hexo s</span><br><span class="line"></span><br><span class="line">// or</span><br><span class="line"></span><br><span class="line">// VSCODE终端</span><br><span class="line">hexo cl; hexo s</span><br></pre></td></tr></table></figure><h3 id="确认无误后使用以下命令，将本地文章推送至GitHub仓库即可"><a href="#确认无误后使用以下命令，将本地文章推送至GitHub仓库即可" class="headerlink" title="确认无误后使用以下命令，将本地文章推送至GitHub仓库即可"></a>确认无误后使用以下命令，将本地文章推送至GitHub仓库即可</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Git BASH终端</span><br><span class="line">hexo cl &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class="line"></span><br><span class="line">// or</span><br><span class="line"></span><br><span class="line">// VSCODE终端</span><br><span class="line">hexo cl; hexo g; hexo d</span><br></pre></td></tr></table></figure><p>下一期会讲讲进阶的使用方法，<code>主题美化</code></p><hr><h2 id="VSCODE-终端首次执行报错"><a href="#VSCODE-终端首次执行报错" class="headerlink" title="VSCODE 终端首次执行报错"></a>VSCODE 终端首次执行报错</h2><p>使用管理员身份打开 powershell ,输入以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-ExecutionPolicy RemoteSigned</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a><br><a href="https://杨幂的脚.dpdns.org/">https://xn--1uto7rutmzjk.dpdns.org/</a></p>]]></content>
      
      
      <categories>
          
          <category> 常用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
