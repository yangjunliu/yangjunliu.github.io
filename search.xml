<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>golang面试常见问题总结</title>
      <link href="/rainbow-bubbles/golang%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/rainbow-bubbles/golang%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言特点"><a href="#Go语言特点" class="headerlink" title="Go语言特点"></a>Go语言特点</h1><p>Go语言相比C++&#x2F;Java等语言是优雅且简洁的，它既保留了C++的高性能，又可以像Java，Python优雅的调用三方库和管理项目，同时还有接口，自动垃圾回收和goroutine等让人拍案叫绝的设计。<br>有许多基于Go的优秀项目。Docker，Kubernetes，etcd，deis，flynn，lime，revel等等。Go无疑是云时代的最好语言！<br>题外话到此为止，在面试中，我们需要深入了解Go语言特性，并适当辅以源码阅读（Go源码非常人性化，注释非常详细，基本上只要你学过Go就能看懂）来提升能力。常考的点包括：切片，通道，异常处理，Goroutine，GMP模型，字符串高效拼接，指针，反射，接口，sync，go test和相关工具链。）</p><h1 id="切片与数组的区别"><a href="#切片与数组的区别" class="headerlink" title="切片与数组的区别"></a>切片与数组的区别</h1><p>在Go语言中，数组（Array）和切片（Slice）是两种不同的数据类型，它们有以下区别： </p><ol><li>长度固定 vs 动态长度：</li></ol><ul><li>数组是长度固定的，在声明时需要指定长度，并且无法改变长度。</li><li>切片是动态长度的，可以根据需要自动调整长度，无需在声明时指定长度。</li></ul><ol start="2"><li>值类型 vs 引用类型：</li></ol><ul><li>数组是值类型，赋值或传递数组时会进行值的复制。</li><li>切片是引用类型，赋值或传递切片时会共享底层数据，修改其中一个切片会影响其他引用该底层数组的切片。</li></ul><ol start="3"><li>内存分配：</li></ol><ul><li>数组在声明时会直接分配连续的内存空间，长度固定。</li><li>切片是基于数组的动态长度的视图，底层使用数组来存储数据，但可以根据需要动态调整切片的长度。</li></ul><ol start="4"><li>灵活性：</li></ol><ul><li>数组的长度固定，无法动态增加或缩小，需要重新创建一个新的数组。</li><li>切片可以通过追加元素或切割操作来动态增加或缩小长度。</li></ul><ol start="5"><li>使用场景：</li></ol><ul><li>数组适用于固定长度的数据集合，如存储一组固定大小的元素。</li><li>切片适用于动态长度的数据集合，如存储可变数量的元素，并且经常需要进行动态调整。</li></ul><p>总的来说，数组适用于长度固定的数据集合，而切片适用于动态长度的数据集合。切片提供了更大的灵活性和方便的操作，是在Go语言中更常用的数据结构。</p><h1 id="切片使用方法"><a href="#切片使用方法" class="headerlink" title="切片使用方法"></a>切片使用方法</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><ol><li>make 函数初始化</li></ol><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><ol start="2"><li>从数组中截取</li></ol><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr := [<span class="number">4</span>]<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s := arr[<span class="number">2</span>:<span class="number">3</span>]</span><br></pre></td></tr></table></figure><h2 id="获取长度和容量"><a href="#获取长度和容量" class="headerlink" title="获取长度和容量"></a>获取长度和容量</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">len</span>(s)</span><br><span class="line"><span class="built_in">cap</span>(s)</span><br></pre></td></tr></table></figure><h2 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr := [<span class="number">4</span>]<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s := arr[<span class="number">2</span>:<span class="number">3</span>]</span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">append</span>(s[:<span class="number">2</span>], s[<span class="number">3</span>:]...)</span><br></pre></td></tr></table></figure><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d:%d\n&quot;</span>, k, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="切片的扩容机制"><a href="#切片的扩容机制" class="headerlink" title="切片的扩容机制"></a>切片的扩容机制</h1><h2 id="Go1-18版前"><a href="#Go1-18版前" class="headerlink" title="Go1.18版前"></a>Go1.18版前</h2><p>新申请的容量如果大于当前容量的两倍，会将新申请的容量直接作为新的容量，如果新申请的容量小于当前容量的两倍，会有一个阈值，即当前切片容量小于1024时，切片会将当前容量的2倍作为新申请的容量，如果大于等于1024，会将当前的容量的1.25倍作为新申请的容量。</p><h3 id="源码片段"><a href="#源码片段" class="headerlink" title="源码片段"></a>源码片段</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">newcap := old.<span class="built_in">cap</span></span><br><span class="line">doublecap := newcap + newcap</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">cap</span> &gt; doublecap &#123;</span><br><span class="line">newcap = <span class="built_in">cap</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> old.<span class="built_in">cap</span> &lt; <span class="number">1024</span> &#123;</span><br><span class="line">newcap = doublecap</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Check 0 &lt; newcap to detect overflow</span></span><br><span class="line"><span class="comment">// and prevent an infinite loop.</span></span><br><span class="line"><span class="keyword">for</span> <span class="number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="built_in">cap</span> &#123;</span><br><span class="line">newcap += newcap / <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Set newcap to the requested cap when</span></span><br><span class="line"><span class="comment">// the newcap calculation overflowed.</span></span><br><span class="line"><span class="keyword">if</span> newcap &lt;= <span class="number">0</span> &#123;</span><br><span class="line">newcap = <span class="built_in">cap</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Go-1-18版本后"><a href="#Go-1-18版本后" class="headerlink" title="Go 1.18版本后"></a>Go 1.18版本后</h2><p>新申请的容量如果大于当前容量的两倍，会将新申请的容量直接作为新的容量，如果新申请的容量小于当前容量的两倍，会有一个阈值，即当前切片容量小于256时，切片会将当前容量的2倍作为新申请的容量，如果大于等于256，会将当前的容量的1.25倍+192作为新申请的容量，扩容的时候更加平滑，不会出现从2到1.25的突变。</p><h3 id="源码片段-1"><a href="#源码片段-1" class="headerlink" title="源码片段"></a>源码片段</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">newcap := old.<span class="built_in">cap</span></span><br><span class="line">doublecap := newcap + newcap</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">cap</span> &gt; doublecap &#123;</span><br><span class="line">newcap = <span class="built_in">cap</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">const</span> threshold = <span class="number">256</span></span><br><span class="line"><span class="keyword">if</span> old.<span class="built_in">cap</span> &lt; threshold &#123;</span><br><span class="line">newcap = doublecap</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Check 0 &lt; newcap to detect overflow</span></span><br><span class="line"><span class="comment">// and prevent an infinite loop.</span></span><br><span class="line"><span class="keyword">for</span> <span class="number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="built_in">cap</span> &#123;</span><br><span class="line"><span class="comment">// Transition from growing 2x for small slices</span></span><br><span class="line"><span class="comment">// to growing 1.25x for large slices. This formula</span></span><br><span class="line"><span class="comment">// gives a smooth-ish transition between the two.</span></span><br><span class="line">newcap += (newcap + <span class="number">3</span>*threshold) / <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Set newcap to the requested cap when</span></span><br><span class="line"><span class="comment">// the newcap calculation overflowed.</span></span><br><span class="line"><span class="keyword">if</span> newcap &lt;= <span class="number">0</span> &#123;</span><br><span class="line">newcap = <span class="built_in">cap</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h1><h2 id="互斥锁-Mutex"><a href="#互斥锁-Mutex" class="headerlink" title="互斥锁 (Mutex)"></a>互斥锁 (Mutex)</h2><p>Mutex是Golang的互斥锁，作用是在并发程序中对共享资源的保护，避免出现数据竞争问题。<br>使用方法：Mutex实现了Locker接口</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Locker <span class="keyword">interface</span> &#123;</span><br><span class="line">    Lock()</span><br><span class="line">    Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是互斥锁 Mutex 提供两个方法 Lock 和 Unlock</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(m *Mutex)</span></span>Lock()</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(m *Mutex)</span></span>Unlock()</span><br></pre></td></tr></table></figure><p>使用实例</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line">    <span class="keyword">import</span> (</span><br><span class="line">        <span class="string">&quot;fmt&quot;</span></span><br><span class="line">        <span class="string">&quot;sync&quot;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 互斥锁保护计数器</span></span><br><span class="line">        <span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">        <span class="comment">// 计数器的值</span></span><br><span class="line">        <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">        wg.Add(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动10个gourontine</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">            <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                <span class="keyword">defer</span> wg.Done()</span><br><span class="line">                <span class="comment">// 累加10万次</span></span><br><span class="line">                <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">100000</span>; j++ &#123;</span><br><span class="line">                    mu.Lock()</span><br><span class="line">                    count++</span><br><span class="line">                    mu.Unlock()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;()</span><br><span class="line">        &#125;</span><br><span class="line">        wg.Wait()</span><br><span class="line">        fmt.Println(count)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Mutex的两种模式"><a href="#Mutex的两种模式" class="headerlink" title="Mutex的两种模式"></a>Mutex的两种模式</h3><p>Mutex 可能处于两种操作模式下：</p><ol><li>正常模式<br>在正常模式下，所有的goroutine会按照先进先出的顺序进行等待，被唤醒的goroutine不会直接持有锁，会和新进来的锁进行竞争，新请求进来的锁会更容易抢占到锁，因为正在CPU上运行，因此刚唤醒的goroutine可能会竞争失败，回到队列头部；如果队列的goroutine超过1毫秒的等待时间，则会转换到饥饿模式。</li><li>饥饿模式<br>在饥饿模式下，锁会直接交给队列的第一个goroutine，新进来的goroutine不会抢占锁也不会进入自旋状态，直接进入队列尾部；如果当前goroutine已经是队列的最后一个或者当前goroutine等待时间小于1毫秒，则会转换到正常模式</li></ol><p>正常模式下，性能更好，但饥饿模式解决取锁公平问题，性能较差。<br>3. 底层结构</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">     state <span class="type">int32</span></span><br><span class="line">     sema  <span class="type">uint32</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">const</span> (</span><br><span class="line">     mutexLocked = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span> <span class="comment">// mutex is locked</span></span><br><span class="line">     mutexWoken</span><br><span class="line">     mutexWaiterShift = <span class="literal">iota</span></span><br><span class="line"> )</span><br></pre></td></tr></table></figure><p>state 是一个复合型的字段，一个字段包含多个意义:</p><p>mutexWaiters 阻塞等待的waiter数量</p><p>mutexStarving 饥饿标记</p><p>mutexWoken 唤醒标记</p><p>mutexLocked 持有锁的标记</p><ol start="4"><li>易错场景</li></ol><ul><li>Lock&#x2F;Unlock没有成对出现（加锁后必须有解锁操作），如果Lock之后，没有Unlock会出现死锁的情况，或者是因为 Unlock 一个未Lock的 Mutex 而导致 panic</li><li>复制已经使用过的Mutex，因为复制了已经使用了的Mutex，导致锁无法使用，程序处于死锁的状态</li><li>重入锁，Mutex是不可重入锁，如果一个线程成功获取到这个锁。之后，如果其它线程再请求这个锁，就会处于阻塞等待的状态</li><li>死锁，两个或两个以上的goroutine争夺共享资源，互相等待对方的锁释放</li></ul><h2 id="读写锁（RWMutex）"><a href="#读写锁（RWMutex）" class="headerlink" title="读写锁（RWMutex）"></a>读写锁（RWMutex）</h2><p>RWMutex 是一个 reader&#x2F;writer 互斥锁。RWMutex 在某一时刻只能由任意数量的 reader goroutine 持有，或者是只被单个的 writer goroutine 持有，适用于读多写少的场景。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ul><li>Lock&#x2F;Unlock：写操作时调用的方法</li><li>RLock&#x2F;RUnlock：读操作时调用的方法</li><li>RLocker：这个方法的作用是为读操作返回一个 Locker 接口的对象。它的 Lock 方法会调用 RWMutex 的 RLock 方法，它的 Unlock 方法会调用 RWMutex 的 RUnlock 方法。</li></ul><p>使用示例：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> counter Counter</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123; <span class="comment">// 10个reader</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                counter.Count() <span class="comment">// 计数器读操作</span></span><br><span class="line">                time.Sleep(time.Millisecond)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123; <span class="comment">// 一个writer</span></span><br><span class="line">        counter.Incr() <span class="comment">// 计数器写操作</span></span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一个线程安全的计数器</span></span><br><span class="line"><span class="keyword">type</span> Counter <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu    sync.RWMutex</span><br><span class="line">    count <span class="type">uint64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用写锁保护</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Counter)</span></span> Incr() &#123;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    c.count++</span><br><span class="line">    c.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用读锁保护</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Counter)</span></span> Count() <span class="type">uint64</span> &#123;</span><br><span class="line">    c.mu.RLock()</span><br><span class="line">    <span class="keyword">defer</span> c.mu.RUnlock()</span><br><span class="line">    <span class="keyword">return</span> c.count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="底层结构"><a href="#底层结构" class="headerlink" title="底层结构"></a>底层结构</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RWMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">  w           Mutex   <span class="comment">// 互斥锁解决多个writer的竞争</span></span><br><span class="line">  writerSem   <span class="type">uint32</span>  <span class="comment">// writer信号量</span></span><br><span class="line">  readerSem   <span class="type">uint32</span>  <span class="comment">// reader信号量</span></span><br><span class="line">  readerCount <span class="type">int32</span>   <span class="comment">// reader的数量（以及是否有 writer 竞争锁）</span></span><br><span class="line">  readerWait  <span class="type">int32</span>   <span class="comment">// writer等待完成的reader的数量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rwmutexMaxReaders = <span class="number">1</span> &lt;&lt; <span class="number">30</span></span><br></pre></td></tr></table></figure><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>一个 writer goroutine 获得了内部的互斥锁，就会反转 readerCount 字段，把它从原来的正整数 readerCount(&gt;&#x3D;0) 修改为负数（readerCount - rwmutexMaxReaders），让这个字段保持两个含义（既保存了 reader 的数量，又表示当前有 writer）。也就是说当readerCount为负数的时候表示当前writer goroutine持有写锁中，reader goroutine会进行阻塞。</p><p>当一个 writer 释放锁的时候，它会再次反转 readerCount 字段。可以肯定的是，因为当前锁由 writer 持有，所以，readerCount 字段是反转过的，并且减去了 rwmutexMaxReaders 这个常数，变成了负数。所以，这里的反转方法就是给它增加 rwmutexMaxReaders 这个常数值。</p><h3 id="易错场景"><a href="#易错场景" class="headerlink" title="易错场景"></a>易错场景</h3><ol><li>复制已经使用的读写锁，会把它的状态也给复制过来，原来的锁在释放的时候，并不会修改你复制出来的这个读写锁，这就会导致复制出来的读写锁的状态不对，可能永远无法释放锁</li><li>重入导致死锁，因为读写锁内部基于互斥锁实现对 writer 的并发访问，而互斥锁本身是有重入问题的，所以，writer 重入调用 Lock 的时候，就会出现死锁的现象</li><li>在 reader 的读操作时调用 writer 的写操作（调用 Lock 方法），那么，这个 reader 和 writer 就会形成互相依赖的死锁状态</li><li>当一个 writer 请求锁的时候，如果已经有一些活跃的 reader，它会等待这些活跃的 reader 完成，才有可能获取到锁，但是，如果之后活跃的 reader 再依赖新的 reader 的话，这些新的 reader 就会等待 writer 释放锁之后才能继续执行，这就形成了一个环形依赖： writer 依赖活跃的 reader -&gt; 活跃的 reader 依赖新来的 reader -&gt; 新来的 reader 依赖 writer</li><li>释放未加锁的 RWMutex，和互斥锁一样，Lock 和 Unlock 的调用总是成对出现的，RLock 和 RUnlock 的调用也必须成对出现。Lock 和 RLock 多余的调用会导致锁没有被释放，可能会出现死锁，而 Unlock 和 RUnlock 多余的调用会导致 panic</li></ol><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>两个或两个以上的进程（或线程，goroutine）在执行过程中，因争夺共享资源而处于一种互相等待的状态，如果没有外部干涉，它们都将无法推进下去，此时，我们称系统处于死锁状态或系统产生了死锁。</p><h2 id="产生死锁的四个必要条件"><a href="#产生死锁的四个必要条件" class="headerlink" title="产生死锁的四个必要条件"></a>产生死锁的四个必要条件</h2><ol><li>互斥：资源只能被一个goroutine持有，其他gouroutine必须等待，直到资源被释放</li><li>持有和等待：goroutine 持有一个资源，并且还在请求其它 goroutine 持有的资源</li><li>不可剥夺：资源只能由持有它的 goroutine 来释放</li><li>环路等待：多个等待goroutine（g1,g2,g3），g1等待g2的资源，g2等待g3的资源，g3等待g1的资源，形成环路等待的死结</li></ol><h2 id="如何解决死锁？（只需要打破必要条件其中一个即可避免死锁）"><a href="#如何解决死锁？（只需要打破必要条件其中一个即可避免死锁）" class="headerlink" title="如何解决死锁？（只需要打破必要条件其中一个即可避免死锁）"></a>如何解决死锁？（只需要打破必要条件其中一个即可避免死锁）</h2><ol><li>设置超时时间</li><li>避免使用多个锁</li><li>按照规定顺序申请锁</li><li>死锁检测</li></ol><h1 id="sync-Cond"><a href="#sync-Cond" class="headerlink" title="sync.Cond"></a>sync.Cond</h1><p>Cond 通常应用于等待某个条件的一组 goroutine，等条件变为 true 的时候，其中一个 goroutine 或者所有的 goroutine 都会被唤醒执行。</p><h2 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NeWCond</span><span class="params">(l Locker)</span></span> *Cond </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Broadcast() </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Signal() </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Wait()</span><br></pre></td></tr></table></figure><ul><li>Singal(): 唤醒一个等待此 Cond 的 goroutine</li><li>Broadcast(): 唤醒所有等待此 Cond 的 goroutine</li><li>Wait(): 放入 Cond 的等待队列中并阻塞，直到被 Signal 或者 Broadcast 的方法从等待队列中移除并唤醒，使用该方法是需要搭配满足条件</li></ul><p>使用示例：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := sync.NewCond(&amp;sync.Mutex&#123;&#125;)</span><br><span class="line">    <span class="keyword">var</span> ready <span class="type">int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            time.Sleep(time.Duration(rand.Int63n(<span class="number">10</span>)) * time.Second)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 加锁更改等待条件</span></span><br><span class="line">            c.L.Lock()</span><br><span class="line">            ready++</span><br><span class="line">            c.L.Unlock()</span><br><span class="line"></span><br><span class="line">            log.Printf(<span class="string">&quot;运动员#%d 已准备就绪\n&quot;</span>, i)</span><br><span class="line">            <span class="comment">// 广播唤醒所有的等待者</span></span><br><span class="line">            c.Broadcast()</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c.L.Lock()</span><br><span class="line">    <span class="keyword">for</span> ready != <span class="number">10</span> &#123;</span><br><span class="line">        c.Wait()</span><br><span class="line">        log.Println(<span class="string">&quot;裁判员被唤醒一次&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    c.L.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//所有的运动员是否就绪</span></span><br><span class="line">    log.Println(<span class="string">&quot;所有运动员都准备就绪。比赛开始，3，2，1, ......&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h1><p>channel用于goroutine之间的通信，go语言中，CSP并发模型，不要通过共享内存实现通信，而是通过通信实现共享内存，就是由goroutine和channel实现的。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li>数据交流</li><li>信号通知</li><li>任务编排</li><li>锁</li></ul><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>初始化</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>) <span class="comment">//有缓冲区</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>) <span class="comment">//无缓冲区</span></span><br></pre></td></tr></table></figure><p>发送数据</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- <span class="number">2</span></span><br></pre></td></tr></table></figure><p>接受数据</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x := &lt;-ch <span class="comment">// 把接收的一条数据赋值给变量x </span></span><br><span class="line">foo(&lt;-ch) <span class="comment">// 把接收的一个的数据作为参数传给函数 </span></span><br><span class="line">&lt;-ch <span class="comment">// 丢弃接收的一条数据</span></span><br></pre></td></tr></table></figure><h2 id="返回容量"><a href="#返回容量" class="headerlink" title="返回容量"></a>返回容量</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="built_in">cap</span>(ch)</span><br></pre></td></tr></table></figure><h2 id="返回channel中缓存的还未被取走的元素数量"><a href="#返回channel中缓存的还未被取走的元素数量" class="headerlink" title="返回channel中缓存的还未被取走的元素数量"></a>返回channel中缓存的还未被取走的元素数量</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">l := <span class="built_in">len</span>(ch)</span><br></pre></td></tr></table></figure><h2 id="关闭channel"><a href="#关闭channel" class="headerlink" title="关闭channel"></a>关闭channel</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure><h2 id="遍历channel"><a href="#遍历channel" class="headerlink" title="遍历channel"></a>遍历channel</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种</span></span><br><span class="line"><span class="keyword">var</span> ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>) </span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123; </span><br><span class="line">  <span class="keyword">select</span> &#123; </span><br><span class="line">  <span class="keyword">case</span> ch &lt;- i: </span><br><span class="line">  <span class="keyword">case</span> v := &lt;-ch: fmt.Println(v) </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种</span></span><br><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> ch &#123; </span><br><span class="line">  fmt.Println(v) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="底层结构-1"><a href="#底层结构-1" class="headerlink" title="底层结构"></a>底层结构</h2><p>qcount 已经接收但还未被取走的元素个数 内置函数len获取到</p><p>datasiz 循环队列的大小 暂时认为是cap容量的值</p><p>elemtype和elemsize 声明chan时到元素类型和大小 固定</p><p>buf 指向缓冲区的指针 无缓冲通道中 buf的值为nil</p><p>sendx 处理发送进来数据的指针在buf中的位置 接收到数据 指针会加上elemsize，移向下一个位置</p><p>recvx 处理接收请求（发送出去）的指针在buf中的位置</p><p>recvq 如果没有数据可读而阻塞， 会加入到recvq队列中</p><p>sendq 向一个满了的buf 发送数据而阻塞，会加入到sendq队列中</p><h2 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h2><p>向channel写数据的流程：</p><p>有缓冲区：<br>优先查看recvq是否为空，如果不为空，优先唤醒recvq的中goroutine，并写入数据；如果队列为空，则写入缓冲区，如果缓冲区已满则写入sendq队列；</p><p>无缓冲区：<br>直接写入sendq队列</p><p>向channel读数据的流程：</p><p>有缓冲区：优先查看缓冲区，如果缓冲区有数据并且未满，直接从缓冲区取出数据；<br>如果缓冲区已满并且sendq队列不为空，优先读取缓冲区头部的数据，并将队列的G的数据写入缓冲区尾部；</p><p>无缓冲区：将当前goroutine加入recvq队列，等到写goroutine的唤醒</p><h2 id="易错点"><a href="#易错点" class="headerlink" title="易错点"></a>易错点</h2><ul><li>channel未初始化，写入或者读取都会阻塞</li><li>往close的channel写入数据会发生panic</li><li>close未初始化channel会发生panic</li><li>close已经close过的channel会发生panic</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>swoole面试常见问题</title>
      <link href="/rainbow-bubbles/swoole%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <url>/rainbow-bubbles/swoole%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍swoole"><a href="#介绍swoole" class="headerlink" title="介绍swoole"></a>介绍swoole</h1><p>首先 swoole 是 php 的一个扩展程序，swoole 是一个为 php 用 c 和 c++ 编写的基于事件的高性能异步 &amp; 协程并行网络通信引擎。<br>swoole 是一个多进程模型的框架，当启动一个进程 swoole 应用时，一共会创建 2+n+m 个进程，n 为 worker 进程数，m 为 TaskWorker 进程数，1 个 master 进程和一个 manager 进程，关系如下图所示<br><img src="https://r2.721503.xyz/blog/1747295555838.png"></p><h2 id="Reactor-线程"><a href="#Reactor-线程" class="headerlink" title="Reactor 线程"></a>Reactor 线程</h2><ul><li>负责维护客户端 <code>TCP</code> 连接、处理网络 <code>IO</code>、处理协议、收发数据</li><li>完全是异步非阻塞的模式</li><li>全部为 <code>C</code> 代码，除 <code>Start/Shudown</code> 事件回调外，不执行任何 PHP 代码</li><li>将 <code>TCP</code> 客户端发来的数据缓冲、拼接、拆分成完整的一个请求数据包</li><li><code>Reactor</code> 以多线程的方式运行</li></ul><h2 id="Worker-进程"><a href="#Worker-进程" class="headerlink" title="Worker 进程"></a>Worker 进程</h2><ul><li>接受由 <code>Reactor</code> 线程投递的请求数据包，并执行 <code>PHP</code> 回调函数处理数据</li><li>生成响应数据并发给 <code>Reactor</code> 线程，由 <code>Reactor</code> 线程发送给 <code>TCP</code> 客户端</li><li>可以是异步非阻塞模式，也可以是同步阻塞模式</li><li>Worker 以多进程的方式运行</li></ul><h2 id="TaskWorker-进程"><a href="#TaskWorker-进程" class="headerlink" title="TaskWorker 进程"></a>TaskWorker 进程</h2><ul><li>接受由 Worker 进程通过 swoole_server-&gt;task&#x2F;taskwait方法投递的任务</li><li>处理任务，并将结果数据返回（使用 swoole_server-&gt;finish）给 Worker 进程</li><li>完全是同步阻塞模式</li><li>TaskWorker 以多进程的方式运行</li></ul><h2 id="网络通信引擎"><a href="#网络通信引擎" class="headerlink" title="网络通信引擎"></a>网络通信引擎</h2><p>网络通信引擎，是为 php 提供网络通信能力的，传统的 php 程序都是启动 php-fpm，前边再有一层 nginx 或者 apache，打开浏览器访问就 OK，但是从浏览器访问到服务器这一阶段涉及到了网络强求，但是这一阶段跟 php 脚本没有任何的关系，php 只需要处理好数据生成需要展示的内容就完成使命了，声明周期当中，请求到来前和请求完成后都没有 php 脚本什么事，而 swoole 提供的一大能力就是扩展了 php 的生命周期，无需 php-fpm 或者 nginx 或者 apache 之类的工具帮助就可以启动一个 web 服务，并且从服务启动前，启动后，链接进入，请求到来，请求结束，链接切断，服务终止都在 php 脚本的掌控之中，这样的话 php 脚本就会涉及到大量的网络通讯处理，而这个网络通讯处理的能力正是来源于 swoole! </p><h2 id="基于事件的高性能异步"><a href="#基于事件的高性能异步" class="headerlink" title="基于事件的高性能异步"></a>基于事件的高性能异步</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$data</span> = <span class="title function_ invoke__">file_contents</span>(<span class="string">&#x27;./data.json&#x27;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$data</span>;</span><br></pre></td></tr></table></figure><p>就拿读取文件内容来说吧，<code>ile_get_contents()</code> 执行完才能执行下边的代码 这样就很容易造成程序的阻塞。</p><p>否则下边的代码就无法输出文件的内容<br>传统 php 都是这样阻塞式的顺序执行的</p><p>这是常见的同步编程<br>异步：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">success</span>: <span class="keyword">function</span>(<span class="params">a</span>) &#123;</span><br><span class="line">        $.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">            <span class="attr">url</span>: <span class="string">&quot;bar&quot;</span>,</span><br><span class="line">            <span class="attr">data</span>: a,</span><br><span class="line">            <span class="attr">success</span>: <span class="keyword">function</span>(<span class="params">b</span>) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(b)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(lll)</span><br></pre></td></tr></table></figure><p>代码在执行到 ajax 的时候，函数会直接返回，你马上就可以看到屏幕上打印出的lll</p><p>这就是异步，这样你永远不会被 IO 阻塞，但是它带来了新的问题，在你运行到 lol 之后你就不知道现在代码运行到哪里去了，你只能等待回调被触发，然后屏幕上打印响应的 log, 它的执行不是单层顺序的，而是嵌套的<br>如果在业务代码当中 这样层层嵌套可读性可想而知<br>当然这是前端异步请求后端接口<br>swoole 当中处理异步回调嵌套使用的是协程<br>你知道什么叫协程吗？你知道线程是干啥的吗？你又知道进程吗？<br>如果想深入了解 swoole 的强大之处 你还得要了解传统 php 的 lnmp 环境的整套运行机制，这些你都了解吗？</p><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>通俗的说，协程就是一段段协作方式执行的程序，协作来完成一件事，协作就是协同作业。我们知道团队协同来做事，比个人单独来做事，效率肯定要高，因为团队协同可以发挥各成员的能动性、优势互补。这是拿人来比喻。我们拿做事来比喻举个例子：比如我们做饭，比如有以下环节洗菜、切菜、烧水、炒菜、煮米饭，人作为主体来操作，那么如果按部就班的做，先烧水，再洗菜，在切菜，再炒菜，再煮饭，那这顿饭要做很长时间比如总共 30 分钟吧，如果我们通过协同方式，先烧水，放灶火上就可以做其他洗菜、切菜的准备，再煮米饭，然后再来洗菜、切菜，再查看煮米饭，再炒菜，…，如此循环往复切换，最后水烧好，米饭也煮好了，菜也炒好了，饭也 OK 了，这样我们耗时可能只有 10-15 分钟，看到了吗，这就是生活中的 “协程”，由人来合理调度安排不同的环节，充分利用各种不同的资源和时间，来达到提高效率。协程是计算机程序，调用的则是不同的程序，处理者主要由 CPU 完成，处理对象是各种 IO 资源，处理的方式是不同的语言编写的程序。我们知道，CPU 可以调度不同的程序，让程序调用不同的 IO 资源，最初的进程是通过 CPU 频繁的切换来完成调用程序的，是操作系统按一定算法分配的时间片抢占被动方式来切换的，未考虑程序实际执行状况，这样切换程序会带来一定问题，而协程作为一种新的工作模式，可以让程序协作方式来执行，在需要使用 CPU 时，交给程序处理，遇到耗时的 IO 资源操作时会让出 CPU，交给处理其他程序，这样互相协作来执行，而不是抢占式的，就像交通规则，大家都遵守按一定规则礼让先行，不随便抢道，协同方式，程序都会执行的良好。</p><p>例子：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">go</span>(function () &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;hello go1 \n&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;hello main \n&quot;</span>;</span><br><span class="line"><span class="title function_ invoke__">go</span>(function () &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;hello go2 \n&quot;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">swoole# php co.php</span><br><span class="line">hello go1</span><br><span class="line">hello main</span><br><span class="line">hello go2</span><br></pre></td></tr></table></figure><p>执行结果和我们平时写代码的顺序，好像没啥区别。实际执行过程:</p><ul><li>运行此段代码，系统启动一个新进程</li><li>遇到 <code>go()</code>, 当前进程中生成一个协程，协程中输出 <code>heelo go1</code>, 协程退出</li><li>进程继续向下执行代码，输出 <code>hello main</code></li><li>再生成一个协程，协程中输出 <code>heelo go2</code>, 协程退出</li></ul><p>再看看这个例子：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="title">Co</span>;</span><br><span class="line"><span class="title function_ invoke__">go</span>(function () &#123;</span><br><span class="line"><span class="title class_">Co</span>::<span class="title function_ invoke__">sleep</span>(<span class="number">1</span>); <span class="comment">// 只新增了一行代码</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;hello go1 \n&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;hello main \n&quot;</span>;</span><br><span class="line"><span class="title function_ invoke__">go</span>(function () &#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;hello go2 \n&quot;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>输出结果：<br>\Co::sleep () 函数功能和 sleep () 差不多，但是它模拟的是 IO 等待 (IO 后面会细讲). </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">swoole<span class="comment"># php co.php</span></span><br><span class="line">hello main</span><br><span class="line">hello go2</span><br><span class="line">hello go1</span><br></pre></td></tr></table></figure><p>可以看出代码是异步执行的</p><h2 id="协程快在哪？减少-IO-阻塞导致的性能损失"><a href="#协程快在哪？减少-IO-阻塞导致的性能损失" class="headerlink" title="协程快在哪？减少 IO 阻塞导致的性能损失"></a>协程快在哪？减少 IO 阻塞导致的性能损失</h2><p>大家可能听到使用协程的最多的理由，可能就是 协程快. 那看起来和平时写得差不多的代码，为什么就要快一些呢？一个常见的理由是，可以创建很多个协程来执行任务，所以快. 这种说法是对的，不过还停留在表面。</p><h3 id="首先，一般的计算机任务分为-2-种："><a href="#首先，一般的计算机任务分为-2-种：" class="headerlink" title="首先，一般的计算机任务分为 2 种："></a>首先，一般的计算机任务分为 2 种：</h3><ul><li>CPU 密集型，比如加减乘除等科学计算</li><li>IO 密集型，比如网络请求，文件读写等<br>其次，高性能相关的 2 个概念：</li></ul><h3 id="并行：同一个时刻，同一个-CPU-只能执行同一个任务，要同时执行多个"><a href="#并行：同一个时刻，同一个-CPU-只能执行同一个任务，要同时执行多个" class="headerlink" title="并行：同一个时刻，同一个 CPU 只能执行同一个任务，要同时执行多个"></a>并行：同一个时刻，同一个 CPU 只能执行同一个任务，要同时执行多个</h3><ul><li>任务，就需要有多个 CPU 才行</li><li>并发：由于 CPU 切换任务非常快，快到人类可以感知的极限，就会有很多任务 同时执行 的错觉</li></ul><p>了解了这些，我们再来看协程，协程适合的是 IO 密集型 应用，因为协程在 IO 阻塞 时会自动调度，减少 IO 阻塞导致的时间损失！<br>协程在遇到 IO 阻塞的时候会让出 cpu 的控制权，其他协程拿到去执行其他协程的任务，当 IO 阻塞过去之后回过头来继续往下执行！</p><h3 id="要点："><a href="#要点：" class="headerlink" title="要点："></a>要点：</h3><ol><li>协程在阻塞的时候只是阻塞了当前这个协程 并不会阻塞整个的进程 因为协程是在线程内部的，即使阻塞了也会让出控制权，挂起，等待当前协程的 IO 不阻塞在回过头来继续执行，也就是同步的代码完成了异步的功能！相当强悍！</li><li>从宏观的角度看，程序员搞出来的多个协程在不发生任何协程阻塞的前提是是顺序执行的 一旦发生阻塞 你可以把多个协程理解为并行的 同时在执行的！</li><li>协程是在单进程单线程当中实现的 你可以在里面实现成千上万的协程 并且效果极高！ 每个协程去干不同的事！协作制的无需加锁没有抢占，串行的！什么叫串行呢？每次执行一个协程 遇到 IO 阻塞 挂起 执行接下来的程序 可能还是个协程 如果再遇到 IO 阻塞再挂起 继续往下执行 当 IO 阻塞完成回过头来继续往下执行没执行完的协程程序 每次都是一个协程在执行，串行化的！</li><li>协程之间每秒可以进行百万千万次切换！ 线程之间切换需要加锁 加锁就很浪费资源！进程间切换更浪费资源，因为上线很大。</li><li>协程很小切换还快 每秒百万千万级别的切换 所以 一个进程里面 只要你的内存够用 你就可以无止境的创造协程出来干事情！</li><li>事件驱动和异步为 swoole 提供了高性能 而协程解决了异步回调代码嵌套的问题 提高了代码可读性和维护性 也是 swoole 最大的特色！</li></ol><h2 id="协程之间通讯-channel"><a href="#协程之间通讯-channel" class="headerlink" title="协程之间通讯 channel"></a>协程之间通讯 channel</h2><p>通道（channel）是协程之间通信交换数据的唯一渠道，而协程 + 通道的开发组合即为著名的 csp 编程模型<br>在 swoole 当中 channel 常用于连接池的实现和协程并发的调度<br>如图所示 第一个协程执行完成之后我们会往 channel 通道当中 push 一个元素 第二个也是 当然第一个一定是 IO 阻塞的 第二个没有 我们在 for 循环里面 获取 channel 里面的值的时候由于第一个阻塞 chan−&gt;pop()也是阻塞的因为整体都是在一个协程里面只有当大的协程里面的两个小协程都完成了这里的chan-&gt;pop () 也是阻塞的 因为整体都是在一个协程里面 只有当大的协程里面的两个小协程都完成了 这里的 chan−&gt;pop()也是阻塞的因为整体都是在一个协程里面只有当大的协程里面的两个小协程都完成了这里的chan-&gt;pop 才会执行 接触阻塞 最后才会执行 echo 语句！ 这是 swoole 当中协程并发的一个很好的案例应用</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">use</span> <span class="title">Swoole</span>\<span class="title">Coroutine</span> <span class="keyword">as</span> <span class="title">co</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">query</span>(<span class="params"><span class="keyword">array</span> <span class="variable">$sql</span></span>)</span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">go</span>(function() &#123;</span><br><span class="line">    <span class="variable">$chan</span> = <span class="keyword">new</span> co\<span class="title function_ invoke__">Channel</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="title function_ invoke__">go</span>(function() <span class="keyword">use</span> ($<span class="title">chan</span>) &#123;</span><br><span class="line">        $<span class="title">var</span> = <span class="title">query</span>(...);</span><br><span class="line">        <span class="variable">$chan</span>-&gt;<span class="title function_ invoke__">push</span>(<span class="variable">$var</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">go</span>(function() <span class="keyword">use</span> ($<span class="title">chan</span>) &#123;</span><br><span class="line">        $<span class="title">var</span> = <span class="title">query</span>(...);</span><br><span class="line">        <span class="variable">$chan</span>-&gt;<span class="title function_ invoke__">push</span>(<span class="variable">$var</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="variable">$i</span>=<span class="number">0</span>; <span class="variable">$i</span>&lt;<span class="number">2</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">        <span class="variable">$chan</span>-&gt;<span class="title function_ invoke__">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;done&quot;</span> . PHP_EOL;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="毫秒定时器"><a href="#毫秒定时器" class="headerlink" title="毫秒定时器"></a>毫秒定时器</h2><p>毫秒定时器是异步回调的方式来实现的！<br>还可以使用协程方式 采用同步阻塞的方式来实现定时器！<br>之前用 sleep 会阻塞整个进程 现在你在协程里面搞 Co:sleep (0.1) 阻塞的是当前协程 而不会阻塞整个进程！</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">go</span>(function() &#123;</span><br><span class="line">    <span class="variable">$i</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="title class_">Co</span>::<span class="title function_ invoke__">sleep</span>(<span class="number">0.1</span>);</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;Do something...\n&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (++<span class="variable">$i</span> === <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;Done\n&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;All right!\n&quot;</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="swoole-提升性能"><a href="#swoole-提升性能" class="headerlink" title="swoole 提升性能"></a>swoole 提升性能</h1><ol><li>进程常驻内存：<br>swoole本⾝是进程常驻内存，在进程启动的时候就将PHP框架等代码读取并编译完成，不需要每次启动的时候都执⾏编译步骤，⼤⼤降低了脚本的运⾏时间；</li><li>连接池<br>php-fpm的模式php因为每次请求结束时都会销毁所有资源，因此⽆法使⽤连接池；⽽基于swoole的进程常驻内存模式，可以通过连接池的⽅式来加速程序，使⽤连接池既可以降低程序的响应时间，⼜可以有效保护后端资源。</li><li>可以使⽤协程处理异步IO<br>当开发中需要去请求多处的数据，⽽每⼀块的数据单独请求都要花较长时间，常规的php-fpm是阻塞式运⾏，⽆法对这类型的数据处理进⾏加速；⽽基于swoole的程序，可以将这类的业务并⾏化处理，并⾏去请求后端的数据源，能够⼤⼤优化了此类业务的运⾏时间。</li></ol><h1 id="swoole⾥的协程是什么，怎么⽤？为什么协程可以提⾼并发"><a href="#swoole⾥的协程是什么，怎么⽤？为什么协程可以提⾼并发" class="headerlink" title="swoole⾥的协程是什么，怎么⽤？为什么协程可以提⾼并发"></a>swoole⾥的协程是什么，怎么⽤？为什么协程可以提⾼并发</h1><p>协程是通过协作⽽不是抢占的⽅式来进⾏切换，它创建和切换对内存等资源⽐线程⼩的多(可以理解为更⼩的线程)；<br>协程的使⽤是通过Swoole\Coroutine或者Co\命名空间短命名简化类名来创建；<br>协程可以异步处理任务，⽀持并发，并且资源消耗⼩</p><h1 id="⽤了swoole以后，会不会发⽣内存泄漏？如果发⽣了怎么解决？"><a href="#⽤了swoole以后，会不会发⽣内存泄漏？如果发⽣了怎么解决？" class="headerlink" title="⽤了swoole以后，会不会发⽣内存泄漏？如果发⽣了怎么解决？"></a>⽤了swoole以后，会不会发⽣内存泄漏？如果发⽣了怎么解决？</h1><p>swoole由于是常驻内存，⼀旦资源加载进⼊后，会⼀直存在于内存中。对于局部变量，swoole会在回调函数结束后⾃动释放；对于全局变量(lobal声明的变量，static声明的对象属性或者函数内的静态变量和超全局变量)，swoole不会⾃动释放；因此操作不好会发⽣内存泄漏。<br>解决：</p><ol><li>在onClose的时候释放</li><li>在 Swoole 中，可以使用 max_request 和 task_max_request 来避免内存泄露<br>max_request：表示 worker 进程的最大任务数量，当 worker 进程处理的任务数量超过这个参数值时，worker 进程自动退出，如此就达到了释放内存和资源的目的<br>task_max_request：同 max_request 一样</li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 13-swoole-server.php</span></span><br><span class="line"> </span><br><span class="line"><span class="variable">$server</span> = <span class="keyword">new</span> <span class="title class_">Swoole\Server</span>(<span class="string">&#x27;0.0.0.0&#x27;</span>, <span class="number">9501</span>, SWOOLE_PROCESS);</span><br><span class="line"> </span><br><span class="line"><span class="variable">$server</span>-&gt;<span class="title function_ invoke__">set</span>([</span><br><span class="line">   <span class="string">&#x27;worker_num&#x27;</span>       =&gt; <span class="number">1</span>,</span><br><span class="line">   <span class="string">&#x27;task_worker_num&#x27;</span>  =&gt; <span class="number">1</span>,</span><br><span class="line">   <span class="string">&#x27;max_request&#x27;</span>      =&gt; <span class="number">2</span>,</span><br><span class="line">   <span class="string">&#x27;task_max_reqeust&#x27;</span> =&gt; <span class="number">2</span>,</span><br><span class="line">]);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="variable">$server</span>-&gt;<span class="title function_ invoke__">on</span>(<span class="string">&#x27;Receive&#x27;</span>, function (<span class="variable">$server</span>, <span class="variable">$fd</span>, <span class="variable">$fromId</span>, <span class="variable">$data</span>) &#123;</span><br><span class="line">   <span class="variable">$server</span>-&gt;<span class="title function_ invoke__">task</span>(<span class="variable">$data</span>);</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="variable">$server</span>-&gt;<span class="title function_ invoke__">on</span>(<span class="string">&#x27;Task&#x27;</span>, function (<span class="variable">$server</span>, <span class="variable">$taskId</span>, <span class="variable">$fromId</span>, <span class="variable">$data</span>) &#123;</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="variable">$server</span>-&gt;<span class="title function_ invoke__">on</span>(<span class="string">&#x27;Finish&#x27;</span>, function (<span class="variable">$server</span>, <span class="variable">$taskId</span>, <span class="variable">$data</span>) &#123;</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="variable">$server</span>-&gt;<span class="title function_ invoke__">start</span>();</span><br></pre></td></tr></table></figure><p>缺点:<br>max_request 只能用于同步阻塞，无状态的请求响应式服务<br>纯异步的server不应该设置max_request<br>使用Base模式时，max_request无效</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PHP面试常见问题总结</title>
      <link href="/rainbow-bubbles/PHP%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/rainbow-bubbles/PHP%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="PHP面试常见问题总结"><a href="#PHP面试常见问题总结" class="headerlink" title="PHP面试常见问题总结"></a>PHP面试常见问题总结</h1><blockquote><p>部分题目收集自网络</p></blockquote><h2 id="1-echo-print-print-r-var-dump-的区别？"><a href="#1-echo-print-print-r-var-dump-的区别？" class="headerlink" title="1. echo(),print(),print_r(),var_dump()的区别？"></a>1. echo(),print(),print_r(),var_dump()的区别？</h2><p>echo 和 print 只能打印出string，不能打印出结构；<br><code>print(string $arg)</code>只有一个参数;<br><code>echo arg1,arg2</code> 可以输出多个参数;<br><code>print_r</code>和<code>var_dump</code>能打印出结构。比如:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$arr</span> = <span class="keyword">array</span>(<span class="string">&quot;key&quot;</span>=&gt;<span class="string">&quot;value&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="variable">$arr</span>);</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(arr);</span><br></pre></td></tr></table></figure><p><code>print_r</code>和<code>var_dump</code>区别:<br>print_r() 只能打印一些易于理解的信息，且print_r()在打印数组时，会将把数组的指针移到最后边，使用reset() 可让指针回到开始处。 而var_dump()不但能打印复合类型的数据，还能打印资源类型的变量</p><h2 id="2-语句include和require的区别是什么"><a href="#2-语句include和require的区别是什么" class="headerlink" title="2. 语句include和require的区别是什么?"></a>2. 语句include和require的区别是什么?</h2><p>在失败的时候：<br><code>include</code> 产生一个 warning ，而 require 直接产生错误中断；<br><code>require</code> 在运行前载入；<br><code>include</code> 在运行时载入；<br><code>require_once</code> 和 <code>include_once</code> 可以避免重复包含同一文件。</p><h2 id="3-php中传值与传引用有啥区别"><a href="#3-php中传值与传引用有啥区别" class="headerlink" title="3. php中传值与传引用有啥区别?"></a>3. php中传值与传引用有啥区别?</h2><p>&amp;表示传引用；<br>函数中参数传引用会将参数进行改变；<br>一般在输出参数有多个的时候可以考虑使用引用。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$num</span> = <span class="number">10</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">&amp;<span class="variable">$num</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$num</span> = <span class="variable">$num</span> * <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">multiply</span>(<span class="variable">$num</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$num</span>;</span><br></pre></td></tr></table></figure><h2 id="4-下面哪项没有将john添加到users数组中？"><a href="#4-下面哪项没有将john添加到users数组中？" class="headerlink" title="4. 下面哪项没有将john添加到users数组中？"></a>4. 下面哪项没有将john添加到users数组中？</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(a) <span class="variable">$users</span>[] = <span class="string">&#x27;john&#x27;</span>;</span><br><span class="line">(b) <span class="title function_ invoke__">array_add</span>(<span class="variable">$users</span>,<span class="string">&#x27;john&#x27;</span>);</span><br><span class="line">(c) <span class="title function_ invoke__">array_push</span>(<span class="variable">$users</span>,<span class="string">&#x27;john&#x27;</span>);</span><br><span class="line">(d) <span class="variable">$users</span> ||= <span class="string">&#x27;john&#x27;</span>;</span><br></pre></td></tr></table></figure><p>答案为bd，php 里面无 array_add 函数，d项为语法错误的表达;</p><h2 id="5-HTTP协议中几个状态码的含义。"><a href="#5-HTTP协议中几个状态码的含义。" class="headerlink" title="5. HTTP协议中几个状态码的含义。"></a>5. HTTP协议中几个状态码的含义。</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">200 : 请求成功，请求的数据随之返回。</span><br><span class="line">301 : 永久性重定向。</span><br><span class="line">302 : 暂时行重定向。</span><br><span class="line">401 : 当前请求需要用户验证。</span><br><span class="line">403 : 服务器拒绝执行请求，即没有权限。</span><br><span class="line">404 : 请求失败，请求的数据在服务器上未发现。</span><br><span class="line">500 : 服务器错误。一般服务器端程序执行错误。</span><br><span class="line">503 : 服务器临时维护或过载。这个状态时临时性的。</span><br></pre></td></tr></table></figure><h2 id="6-一些php魔术方法。"><a href="#6-一些php魔术方法。" class="headerlink" title="6. 一些php魔术方法。"></a>6. 一些php魔术方法。</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">__construct() 实例化类时自动调用。</span><br><span class="line">__destruct() 类对象使用结束时自动调用。</span><br><span class="line">__set() 在给未定义的属性赋值的时候调用。</span><br><span class="line">__get() 调用未定义的属性时候调用。</span><br><span class="line">__isset() 使用isset()或empty()函数时候会调用。</span><br><span class="line">__unset() 使用unset()时候会调用。</span><br><span class="line">__sleep() 使用serialize序列化时候调用。</span><br><span class="line">__wakeup() 使用unserialize反序列化的时候调用。</span><br><span class="line">__call() 调用一个不存在的方法的时候调用。</span><br><span class="line">__callStatic()调用一个不存在的静态方法是调用。</span><br><span class="line">__toString() 把对象转换成字符串的时候会调用。比如 echo。</span><br><span class="line">__invoke() 当尝试把对象当方法调用时调用。</span><br><span class="line">__set_state() 当使用var_export()函数时候调用。接受一个数组参数。</span><br><span class="line">__clone() 当使用clone复制一个对象时候调用。</span><br></pre></td></tr></table></figure><h2 id="7-MySQL存储引擎-MyISAM-和-InnoDB-的区别。"><a href="#7-MySQL存储引擎-MyISAM-和-InnoDB-的区别。" class="headerlink" title="7. MySQL存储引擎 MyISAM 和 InnoDB 的区别。"></a>7. MySQL存储引擎 MyISAM 和 InnoDB 的区别。</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a. MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持.</span><br><span class="line">b. MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快.</span><br><span class="line">c. InnoDB不支持FULLTEXT类型的索引.</span><br><span class="line">d. InnoDB中不保存表的具体行数，也就是说，执行select count(*) from table时，InnoDB要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可.</span><br><span class="line">e. 对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引。</span><br><span class="line">f. DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除。</span><br><span class="line">g. LOAD TABLE FROM MASTER操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性(例如外键)的表不适用.</span><br><span class="line">h. MyISAM支持表锁，InnoDB支持行锁。</span><br></pre></td></tr></table></figure><h2 id="8-说出一些MySQL优化方法？"><a href="#8-说出一些MySQL优化方法？" class="headerlink" title="8. 说出一些MySQL优化方法？"></a>8. 说出一些MySQL优化方法？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a. 设计良好的数据库结构，允许部分数据冗余，尽量避免join查询，提高效率。</span><br><span class="line">b. 选择合适的表字段数据类型和存储引擎，适当的添加索引。</span><br><span class="line">c. mysql库主从读写分离。</span><br><span class="line">d. 找规律分表，减少单表中的数据量提高查询速度。</span><br><span class="line">e. 添加缓存机制，比如memcached，apc等。</span><br><span class="line">f. 不经常改动的页面，生成静态页面。</span><br><span class="line">g. 书写高效率的SQL。比如 SELECT * FROM TABEL 改为 SELECT field_1, field_2, field_3 FROM TABLE.</span><br></pre></td></tr></table></figure><h2 id="9-说下php中empty-和isset-的区别。"><a href="#9-说下php中empty-和isset-的区别。" class="headerlink" title="9. 说下php中empty()和isset()的区别。"></a>9. 说下php中empty()和isset()的区别。</h2><p><code>isset</code> 用于检测变量是否被设置，使用 <code>isset()</code> 测试一个被设置成 <code>NULL</code> 的变量，将返回 <code>FALSE</code> 。<br><code>empty</code> 如果 <code>var</code> 是非空或非零的值，则 <code>empty()</code> 返回 <code>FALSE</code>。换句话说，<code>&quot;&quot;、0、&quot;0&quot;、NULL、FALSE、array()、var $var</code>; 以及没有任何属性的对象都将被认为是空的，如果 <code>var</code> 为空，则返回 <code>TRUE</code> 。</p><h2 id="10-for与foreach哪个更快"><a href="#10-for与foreach哪个更快" class="headerlink" title="10. for与foreach哪个更快?"></a>10. for与foreach哪个更快?</h2><p><code>foreach</code> 的效率要比 <code>for</code> 高很多，也许有很大的一个原因是 <code>for</code> 要进行很多次条件判断。所以以后能用 <code>foreach</code> 的地方就用 <code>foreach</code> ，可以提高1倍的效率。<br>如果循环内要调用函数，用 <code>array_walk</code> 最好，它的效率要比 <code>for</code> 高出1倍，要比 <code>foreach</code> 高出43%的效率。</p><h2 id="11-PECL-和-PEAR-有什么区别？"><a href="#11-PECL-和-PEAR-有什么区别？" class="headerlink" title="11. PECL 和 PEAR 有什么区别？"></a>11. PECL 和 PEAR 有什么区别？</h2><p><code>PECL (PHP Extension Community Library)</code> 可以看作 <code>PEAR (PHP Extension and Application Repository)</code> 的一个组成部分，提供了与 <code>PEAR</code> 类似的功能。不同的是 <code>PEAR</code> 的所有扩展都是用纯粹的 PHP 代码编写的，用户在下载到 PEAR 扩展以后可以直接使用将扩展的代码包含到自己的 PHP 文件中使用。而 PECL 是使用 C 语言开发的，通常用于补充一些用 PHP 难以完成的底层功能，往往需要重新编译或者在配置文件中设置后才能在用户自己的代码中使用。</p><p>最直接的表述：<code>PEAR</code> 是 PHP 的上层扩展，<code>PECL</code> 是 PHP 的底层扩展。它们都是为特定的应用提供现成的函数或者类。</p><h2 id="12-如何处理多服务器共享-Session"><a href="#12-如何处理多服务器共享-Session" class="headerlink" title="12. 如何处理多服务器共享 Session ?"></a>12. 如何处理多服务器共享 Session ?</h2><p>大致上有三种方式可以处理：</p><ul><li>数据库&#x2F;文件同步 session</li><li>cookie 同步 session</li><li>缓存 (如 <code>redis</code> ）同步 session</li></ul><h2 id="13-PHP内存管理机制与垃圾回收机制"><a href="#13-PHP内存管理机制与垃圾回收机制" class="headerlink" title="13. PHP内存管理机制与垃圾回收机制?"></a>13. PHP内存管理机制与垃圾回收机制?</h2><p><code>php</code> 的内存管理机制是：预先给出一块空间，用来存储变量，当空间不够时，再申请一块新的空间。</p><ul><li>存储变量名，存在符号表。</li><li>变量值存储在内存空间。</li><li>在删除变量的时候，会将变量值存储的空间释放，而变量名所在的符号表不会减小。</li></ul><p><code>php</code> 垃圾回收机制是：</p><ul><li>在5.2版本或之前版本，PHP会根据 引用计数 （ refcount ）值来判断是不是垃圾，如果refcount值为0，PHP会当做垃圾释放掉，这种回收机制有缺陷，对于环状引用的变量无法回收。</li><li>在5.3之后版本改进了垃圾回收机制。具体如下：<br>如果发现一个 <code>zval</code> 容器中的 <code>refcount</code> 在增加，说明不是垃圾； 如果发现一个 <code>zval</code> 容器中的 refcount 在减少，如果减到了0，直接当做垃圾回收； 如果发现一个 <code>zval</code> 容器中的 <code>refcount</code> 在减少，并没有减到0，PHP 会把该值放到缓冲区，当做有可能是垃圾的怀疑对象； 当缓冲区达到了临界值，PHP 会自动调用一个方法去遍历每一个值，如果发现是垃圾就清理。</li></ul><h2 id="14-多线程和多进程的区别为？"><a href="#14-多线程和多进程的区别为？" class="headerlink" title="14. 多线程和多进程的区别为？"></a>14. 多线程和多进程的区别为？</h2><p>进程是程序在计算机上的一次执行活动。当你运行一个程序，你就启动了一个进程。显然，程序是死的(静态的)，进程是活的(动态的)。进程可以分为系统进程和用户进程。凡是用于完成操作系统的各种功能的进程就是系统进程，它们就是处于运行状态下的操作系统本身；所有由你启动的进程都是用户进程。进程是操作系统进行资源分配的单位。在 Windows 下，进程又被细化为线程，也就是一个进程下有多个能独立运行的更小的单位。</p><h2 id="15-TCP-IP-网络协议，OSI-7-层指是什么？"><a href="#15-TCP-IP-网络协议，OSI-7-层指是什么？" class="headerlink" title="15. TCP&#x2F;IP 网络协议，OSI 7 层指是什么？"></a>15. TCP&#x2F;IP 网络协议，OSI 7 层指是什么？</h2><p><code>TCP/IP</code> 5层 指的是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">应用层</span><br><span class="line">HTTP、FTP、SMTP、DNS、DSP、Telnet、Gopher、WAIS……</span><br><span class="line">传输层</span><br><span class="line">TCP、UDP、DVP……</span><br><span class="line">网络层</span><br><span class="line">IP、ICMP、AKP、RARP、UUCP……</span><br><span class="line">接口层</span><br><span class="line">Ethernet、Arpanet、PDN……</span><br><span class="line">物理层</span><br><span class="line">只要能传输IP数据报（Datagram），允许任何协议……</span><br></pre></td></tr></table></figure><p><code>OSI</code> 7层指的是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">应用层 文件传输，电子邮件，文件服务，虚拟终端 TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet</span><br><span class="line">表示层 数据格式化，代码转换，数据加密 没有协议</span><br><span class="line">会话层 解除或建立与别的接点的联系 没有协议</span><br><span class="line">传输层 提供端对端的接口 TCP，UDP</span><br><span class="line">网络层 为数据包选择路由 IP，ICMP，RIP，OSPF，BGP，IGMP</span><br><span class="line">数据链路层 传输有地址的帧以及错误检测功能 SLIP，CSLIP，PPP，ARP，RARP，MTU</span><br><span class="line">物理层 以二进制数据形式在物理媒体上传输数据 ISO2110，IEEE802，IEEE802.2</span><br></pre></td></tr></table></figure><h2 id="16-laravel-市场目前比较流行的框架"><a href="#16-laravel-市场目前比较流行的框架" class="headerlink" title="16. laravel 市场目前比较流行的框架"></a>16. laravel 市场目前比较流行的框架</h2><ul><li><p>简述 Laravel 的生命周期</p><blockquote><p>Laravel 采用了单一入口模式，应用的所有请求入口都是 public&#x2F;index.php 文件。</p><ol><li>注册类文件自动加载器 : Laravel通过 composer 进行依赖管理，无需开发者手动导入各种类文件，而由自动加载器自行导入。</li><li>创建服务容器：从 bootstrap&#x2F;app.php 文件中取得 Laravel 应用实例 $app (服务容器)</li><li>创建 HTTP &#x2F; Console 内核：传入的请求会被发送给 HTTP 内核或者 console 内核进行处理</li><li>载入服务提供者至容器：<br>在内核引导启动的过程中最重要的动作之一就是载入服务提供者到你的应用，服务提供者负责引导启动框架的全部各种组件，例如数据库、队列、验证器以及路由组件。<blockquote><ol start="5"><li>分发请求：一旦应用完成引导和所有服务提供者都注册完成，Request 将会移交给路由进行分发。路由将分发请求给一个路由或控制器，同时运行路由指定的中间件</li></ol></blockquote></li></ol></blockquote></li><li><p>服务提供者是什么？</p><blockquote><p>服务提供者是所有 Laravel 应用程序引导启动的中心, Laravel 的核心服务器、注册服务容器绑定、事件监听、中间件、路由注册以及我们的应用程序都是由服务提供者引导启动的。</p></blockquote></li><li><p>IoC 容器是什么？</p><blockquote><p>IoC（Inversion of Control）译为 「控制反转」，也被叫做「依赖注入」(DI)。什么是「控制反转」？对象 A 功能依赖于对象 B，但是控制权由对象 A 来控制，控制权被颠倒，所以叫做「控制反转」，而「依赖注入」是实现 IoC 的方法，就是由 IoC 容器在运行期间，动态地将某种依赖关系注入到对象之中。</p><p>其作用简单来讲就是利用依赖关系注入的方式，把复杂的应用程序分解为互相合作的对象，从而降低解决问题的复杂度，实现应用程序代码的低耦合、高扩展。</p><p>Laravel 中的服务容器是用于管理类的依赖和执行依赖注入的工具。</p></blockquote></li><li><p>Facades 是什么？</p><blockquote><p>Facades（一种设计模式，通常翻译为外观模式）提供了一个”static”（静态）接口去访问注册到 IoC 容器中的类。提供了简单、易记的语法，而无需记住必须手动注入或配置的长长的类名。此外，由于对 PHP 动态方法的独特用法，也使测试起来非常容易。</p></blockquote></li><li><p>Contract 是什么？</p><blockquote><p>Contract（契约）是 laravel 定义框架提供的核心服务的接口。Contract 和 Facades 并没有本质意义上的区别，其作用就是使接口低耦合、更简单。</p></blockquote></li><li><p>谈谈 Laravel 和 YII 框架的区别.</p><blockquote><ol><li>在 YII 框架中的路由是通过书写 Controller、Action 间接定义路由，而 Laravel 中是在 route 路由文件中直接定义路由入口</li><li>Laravel 提供 ORM 对象关系映射，使读写数据库的操作更加简单</li><li>Laravel 提供更多的 Artisan 命令和脚手架开发</li><li>Laravel 的 Composer 扩展包比 Yii 框架更多，开发更加高效</li></ol></blockquote></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu安装php</title>
      <link href="/rainbow-bubbles/Ubuntu%E5%AE%89%E8%A3%85php/"/>
      <url>/rainbow-bubbles/Ubuntu%E5%AE%89%E8%A3%85php/</url>
      
        <content type="html"><![CDATA[<h1 id="PHP是什么语言？"><a href="#PHP是什么语言？" class="headerlink" title="PHP是什么语言？"></a>PHP是什么语言？</h1><p>PHP 是一种服务器端编程语言，对用户免费且开源，也可用于制作各种类型的应用程序、网站、CRM 等等。它是一种经常使用的通用语言，可以集成到超文本标记语言 （HTML） 中。基本上在系统中，PHP 提供的八种原始数据类型进一步分为三个内部类别：脚本类型（预先建立）、化合物类型（用户定义）和唯一类型。</p><h1 id="如何在-Ubuntu-上安装-PHP？"><a href="#如何在-Ubuntu-上安装-PHP？" class="headerlink" title="如何在 Ubuntu 上安装 PHP？"></a>如何在 Ubuntu 上安装 PHP？</h1><p>Ubuntu 被称为最常用的开源作系统之一，它负责我们想要开发的应用程序的任何 Web 界面的整体开发，我们将在 Ubuntu 上安装 PHP 并了解在 Ubuntu 上安装 PHP 是多么容易</p><p>我们可以通过两种方法在 Ubuntu 上安装 PHP，让我们了解每种方法：</p><p>使用 apt&#x2F;terminal 安装 PHP</p><ol><li>更新apt</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><p>输出如下：<br><img src="https://r2.721503.xyz/blog/1747213337546.png"></p><ol><li>安装 PHP 软件包</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install php php-cli php-fpm php-json php-common php-mysql php-zip php-gd php-mbstring php-curl php-xml php-pear php-bcmath</span><br></pre></td></tr></table></figure><p>输出如下：确认提示，输入Y<br><img src="https://r2.721503.xyz/blog/1747213522748.png"></p><ol><li>检查是否安装了 PHP</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php -v</span><br></pre></td></tr></table></figure><p>输出如下：看到这个提示代表你已经安装成功<br><img src="https://r2.721503.xyz/blog/1747213640263.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建你的第一篇博客</title>
      <link href="/rainbow-bubbles/%E5%88%9B%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/rainbow-bubbles/%E5%88%9B%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="搭建Hexo博客"><a href="#搭建Hexo博客" class="headerlink" title="搭建Hexo博客"></a>搭建Hexo博客</h1><p>本文介绍如何使用hexo搭建个人博客，并将博客部署到Github Pages和Cloudflare Pages上。主要内容包括：</p><ul><li>环境准备：安装Node.js和Git</li><li>配置Git和Github：设置SSH密钥，创建Github仓库</li><li>初始化Hexo项目：安装Hexo，创建一篇博文</li><li>部署到GitHub Pages：配置部署设置，推送静态文件</li><li>部署到Cloudflare Pages：连接GitHub仓库，自动部署</li><li>基本使用方法：创建新文章，本地预览，发布更新</li></ul><p>这个教程适合那些想要快速搭建个人博客，但又不想花费太多成本的人。通过使用Hexo、GitHub和Cloudflare的免费服务，您可以轻松创建一个高效、简洁的博客网站。</p><h2 id="1-事前准备"><a href="#1-事前准备" class="headerlink" title="1. 事前准备"></a>1. 事前准备</h2><ol><li>域名(非必须，可以使用免费域名或者<code>Github.io</code>或者<code>Pages.dev</code>分配域名)</li><li><a href="https://github.com/">Github</a>（必须，你需要注册一个GitHub帐号）</li><li><a href="https://dash.cloudflare.com/">Cloudflare</a>（非必须，你需要注册一个Cloudflare帐号，这样你就可以将博客部署在CF的CDN里加速，但是你也可以直接使用<code>GitHub.io</code>分配的域名）</li></ol><h2 id="2-软件支持"><a href="#2-软件支持" class="headerlink" title="2. 软件支持"></a>2. 软件支持</h2><ol><li><a href="#21-%E5%AE%89%E8%A3%85-node">Node</a>(必须)</li><li><a href="Git"></a>(必须)</li><li><a href="vscode">https://code.visualstudio.com/</a>(非必须，这是一款轻量型的代码编辑器)</li></ol><h3 id="2-1-安装-Node"><a href="#2-1-安装-Node" class="headerlink" title="2.1. 安装 Node"></a>2.1. 安装 Node</h3><ol><li>打开Node官网，下载和自己系统相配的Node的安装程序，否则会出现安装问题。下载地址：<a href="https://nodejs.org/en">https://nodejs.org/en</a></li><li>下载后安装，安装的目录可以使用默认目录</li><li>安装完成后，检查是否安装成功。在键盘按下win + R键，输入CMD，然后回车，打开CMD窗口，执行<code>node -v</code>命令，看到版本信息，则说明安装成功。</li><li>修改npmmd源。npm下载各种模块，默认是从国处服务器下载，速度较慢，建议配置成华为云镜像源。打开CMD窗口，运行如下命令:</li></ol><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://mirrors.huaweicloud.com/repository/npm/</span><br></pre></td></tr></table></figure><h3 id="2-2-安装-Git"><a href="#2-2-安装-Git" class="headerlink" title="2.2. 安装 Git"></a>2.2. 安装 Git</h3><ol><li>进入官网下载适合你当前系统的 Git：<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a></li><li>下载后傻瓜式安装Git即可，安装的目录最好使用默认目录</li></ol><h2 id="3-配置-Git-密钥并连接至-Github"><a href="#3-配置-Git-密钥并连接至-Github" class="headerlink" title="3. 配置 Git 密钥并连接至 Github"></a>3. 配置 Git 密钥并连接至 Github</h2><p>常用 Git 命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config -l  //查看所有配置</span><br><span class="line">git config --system --list //查看系统配置</span><br><span class="line">git config --global --list //查看用户（全局）配置</span><br></pre></td></tr></table></figure><h3 id="3-1-配置用户名和邮箱"><a href="#3-1-配置用户名和邮箱" class="headerlink" title="3.1. 配置用户名和邮箱"></a>3.1. 配置用户名和邮箱</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;你的用户名&quot;</span><br><span class="line">git config --global user.email &quot;你的邮箱&quot;</span><br></pre></td></tr></table></figure><p>通过<code>git config -l</code>检查是否配置成功</p><h3 id="3-2-配置公钥连接Github"><a href="#3-2-配置公钥连接Github" class="headerlink" title="3.2. 配置公钥连接Github"></a>3.2. 配置公钥连接Github</h3><ol><li>执行以下命令生成ssh公钥，此公钥用于你的计算机连接Github</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;你的邮箱&quot;</span><br></pre></td></tr></table></figure><p>提示<code>Enter file in which to save the key</code>直接一路回车即可，新手小白不推荐设置密钥<br>之后打开C盘下用户文件夹下的.ssh的文件夹，会看到以下文件<br>2. 将 SSH KEY 配置到 GitHub<br>进入github，点击右上角头像 选择<code>settings</code>，进入设置页后选择<code>SSH and GPG keys</code>，名字随便起，公钥填到<code>Key</code>那一栏。<br>3. 测试连接，输入以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><h3 id="3-3-创建GitHub-io仓库"><a href="#3-3-创建GitHub-io仓库" class="headerlink" title="3.3. 创建GitHub.io仓库"></a>3.3. 创建GitHub.io仓库</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/rainbow-bubbles/hello-world/"/>
      <url>/rainbow-bubbles/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
